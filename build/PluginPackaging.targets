<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!--
    Plugin Packaging with ILRepack Assembly Merging

    Merges plugin dependencies into a single DLL for self-contained deployment.

    NOTE: Internalize="true" is REQUIRED to prevent DryIoc conflicts. When types
    from merged assemblies (Polly, TagLibSharp, etc.) remain public, they can
    conflict with Lidarr's own types during DI container resolution.

    USAGE:
    1. Add ILRepack.Lib.MSBuild.Task package with ExcludeAssets="build" and GeneratePathProperty="true"
    2. Import this targets file
    3. Optionally set LidarrAssembliesPath
  -->

  <!-- Import ILRepack task from NuGet package - supports both netfx and netcore -->
  <UsingTask TaskName="ILRepack"
             AssemblyFile="$(PkgILRepack_Lib_MSBuild_Task)/build/ILRepack.Lib.MSBuild.Task.dll"
             Condition="'$(PkgILRepack_Lib_MSBuild_Task)' != '' and Exists('$(PkgILRepack_Lib_MSBuild_Task)/build/ILRepack.Lib.MSBuild.Task.dll')" />

  <PropertyGroup>
    <PluginAssemblyFileName Condition="'$(PluginAssemblyFileName)' == ''">$(AssemblyName).dll</PluginAssemblyFileName>
    <PluginSymbolFileName Condition="'$(PluginSymbolFileName)' == ''">$(AssemblyName).pdb</PluginSymbolFileName>
    <PluginManifestFileName Condition="'$(PluginManifestFileName)' == ''">plugin.json</PluginManifestFileName>
    <EnablePluginDeployment Condition="'$(EnablePluginDeployment)' == ''">false</EnablePluginDeployment>
    <PluginPackagingDisable Condition="'$(PluginPackagingDisable)' == ''">false</PluginPackagingDisable>
    <!-- Disable ILRepack.Lib.MSBuild.Task built-in target - we use our own RepackPlugin target -->
    <ILRepackEnabled>false</ILRepackEnabled>
  </PropertyGroup>

  <!-- NOTE: PluginMergeDependency is defined INSIDE RepackPlugin target so Exists() checks
       happen AFTER the build copies dependencies to OutputPath, not at project load time -->

  <Target Name="RepackPlugin" AfterTargets="Build" Condition="'$(PluginPackagingDisable)' != 'true'">
    <!-- Compute library paths at runtime (after build) when OutputPath is fully resolved -->
    <PropertyGroup>
      <!-- Absolute path to plugin output directory (where all runtime deps are copied) -->
      <_PluginOutputDir>$(TargetDir)</_PluginOutputDir>
      <_PluginOutputPath>$(TargetDir)</_PluginOutputPath>
      <!-- Paths relative to this targets file (inside Common submodule) -->
      <_CommonLibraryPath>$(MSBuildThisFileDirectory)../src/bin/$(Configuration)/$(TargetFramework)</_CommonLibraryPath>
      <_AbstractionsPath>$(MSBuildThisFileDirectory)../src/Abstractions/bin/$(Configuration)/$(TargetFramework)</_AbstractionsPath>
      <!-- Paths to Lidarr assemblies (for reference resolution, typically at repo root/ext/Lidarr) -->
      <_LidarrAssembliesPath Condition="'$(LidarrAssembliesPath)' == ''">$(MSBuildProjectDirectory)/../../ext/Lidarr/_output/net6.0;$(MSBuildProjectDirectory)/../../ext/Lidarr/_output/net8.0</_LidarrAssembliesPath>
      <_LidarrAssembliesPath Condition="'$(LidarrAssembliesPath)' != ''">$(LidarrAssembliesPath)</_LidarrAssembliesPath>
      <!-- Combined library paths for ILRepack - plugin output first (has all NuGet deps) -->
      <_ILRepackLibraryPaths>$(_PluginOutputDir);$(_LidarrAssembliesPath);$(_CommonLibraryPath);$(_AbstractionsPath)</_ILRepackLibraryPaths>
    </PropertyGroup>

    <!-- Detect dependencies at runtime (after build), not at project load time -->
    <ItemGroup>
      <_PluginDeps Include="$(_PluginOutputPath)Lidarr.Plugin.Common.dll" Condition="Exists('$(_PluginOutputPath)Lidarr.Plugin.Common.dll')" />
      <!-- NOTE: Lidarr.Plugin.Abstractions must NOT be merged - it contains IPlugin and other interfaces
           that must have identical type identity with the host. Merging breaks plugin loading. -->
      <!-- <_PluginDeps Include="$(OutputPath)Lidarr.Plugin.Abstractions.dll" /> DO NOT ENABLE - breaks IPlugin type identity -->
      <_PluginDeps Include="$(_PluginOutputPath)Polly.dll" Condition="Exists('$(_PluginOutputPath)Polly.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Polly.Core.dll" Condition="Exists('$(_PluginOutputPath)Polly.Core.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Polly.Extensions.Http.dll" Condition="Exists('$(_PluginOutputPath)Polly.Extensions.Http.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)TagLibSharp*.dll" />
      <!-- Microsoft.Extensions packages - merge implementation assemblies but NOT abstractions.
           Abstractions must maintain type identity with host for DI to work correctly. -->
      <!-- DO NOT MERGE: Microsoft.Extensions.DependencyInjection.Abstractions - breaks IServiceProvider contracts -->
      <!-- DO NOT MERGE: Microsoft.Extensions.Logging.Abstractions - breaks ILogger contracts -->
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.DependencyInjection.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.DependencyInjection.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.Caching.Abstractions.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.Caching.Abstractions.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.Caching.Memory.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.Caching.Memory.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.Options.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.Options.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.Primitives.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.Primitives.dll')" />
      <_PluginDeps Include="$(_PluginOutputPath)Microsoft.Extensions.Http.dll" Condition="Exists('$(_PluginOutputPath)Microsoft.Extensions.Http.dll')" />
      <!-- NOTE: FluentValidation must NOT be merged (ILRepacked) - it breaks DownloadClient.Test(List<ValidationFailure>).
           If FluentValidation.dll should be shipped as a separate file, that is handled by the post-merge cleanup step below. -->
      <!-- NOTE: System.Text.Json must NOT be merged - its types cross the host/plugin boundary -->
      <!-- and can cause TypeLoadException or serialization issues -->
      <!-- <_PluginDeps Include="$(OutputPath)System.Text.Json.dll" /> DO NOT ENABLE - cross-boundary type issues -->
      <_PluginDeps Include="@(PluginPackagingAdditionalMerge)" />
    </ItemGroup>

    <ItemGroup>
      <_AssembliesToMerge Include="$(TargetPath)" />
      <_AssembliesToMerge Include="@(_PluginDeps)" />
    </ItemGroup>

    <Message Text="[ILRepack] Found dependencies to merge: @(_PluginDeps->'%(Filename)')" Importance="high" />
    <Message Text="[ILRepack] Library paths: $(_ILRepackLibraryPaths)" Importance="high" />
    <Message Text="[ILRepack] Merging plugin assemblies..." Importance="high" />

    <!-- Create temp directory for ILRepack output to preserve correct assembly identity.
         IMPORTANT: OutputFile filename determines the internal assembly name, not just the file name.
         Using $(AssemblyName).dll (not *.merged.dll) ensures the merged assembly has the correct identity. -->
    <PropertyGroup>
      <_ILRepackTempDir>$(IntermediateOutputPath)ilrepack-temp\</_ILRepackTempDir>
    </PropertyGroup>
    <MakeDir Directories="$(_ILRepackTempDir)" />

    <!-- NOTE: Internalize="true" prevents merged assembly types from conflicting with Lidarr types -->
    <ILRepack
      Parallel="true"
      Internalize="true"
      DebugInfo="true"
      TargetKind="Dll"
      InputAssemblies="@(_AssembliesToMerge)"
      OutputFile="$(_ILRepackTempDir)$(AssemblyName).dll"
      LibraryPath="$(_ILRepackLibraryPaths)" />

    <Copy SourceFiles="$(_ILRepackTempDir)$(AssemblyName).dll"
          DestinationFiles="$(_PluginOutputPath)$(PluginAssemblyFileName)"
          OverwriteReadOnlyFiles="true" />

    <Copy SourceFiles="$(_ILRepackTempDir)$(AssemblyName).pdb"
          DestinationFiles="$(_PluginOutputPath)$(PluginSymbolFileName)"
          OverwriteReadOnlyFiles="true"
          Condition="Exists('$(_ILRepackTempDir)$(AssemblyName).pdb')" />

    <RemoveDir Directories="$(_ILRepackTempDir)" />


    <!-- PLUGIN PACKAGE CONTENTS POLICY

         MUST SHIP:
           - Lidarr.Plugin.<Name>.dll (merged assembly)
           - plugin.json
           - Lidarr.Plugin.Abstractions.dll (plugin discovery; host does NOT provide this)

         MUST NOT SHIP (host-provided / cross-boundary type-identity):
           - FluentValidation.dll
           - Microsoft.Extensions.DependencyInjection.Abstractions.dll
           - Microsoft.Extensions.Logging.Abstractions.dll
           - NLog.dll
           - System.Text.Json.dll
           - Host assemblies (Lidarr.*.dll, NzbDrone.*.dll, etc.)

         MERGED/INTERNALIZED:
           - Lidarr.Plugin.Common.dll, Polly*, TagLibSharp*, etc. (via ILRepack above)
    -->
    <ItemGroup>
      <!-- Runtime dependency assemblies to keep as separate files -->
      <_PluginRuntimeDeps Include="$(_PluginOutputPath)Lidarr.Plugin.Abstractions.dll"
                         Condition="Exists('$(_PluginOutputPath)Lidarr.Plugin.Abstractions.dll')" />
      <_PluginRuntimeDeps Include="@(PluginPackagingAdditionalKeep)" />

      <!-- Everything else gets deleted - either merged above or host-provided -->
      <_ExtraAssemblies Include="$(_PluginOutputPath)*.dll" Exclude="$(_PluginOutputPath)$(PluginAssemblyFileName);@(_PluginRuntimeDeps)" />
      <_ExtraSymbols Include="$(_PluginOutputPath)*.pdb" Exclude="$(_PluginOutputPath)$(PluginSymbolFileName)" />
    </ItemGroup>

    <Message Text="[ILRepack] Keeping runtime dependencies: @(_PluginRuntimeDeps->'%(Filename)')" Importance="high" Condition="'@(_PluginRuntimeDeps)' != ''" />
    <Message Text="[ILRepack] Deleting extra assemblies: @(_ExtraAssemblies->'%(Filename)')" Importance="high" Condition="'@(_ExtraAssemblies)' != ''" />
    <Delete Files="@(_ExtraAssemblies)" />
    <Delete Files="@(_ExtraSymbols)" />
    <Delete Files="$(_PluginOutputPath)$(AssemblyName).deps.json" Condition="Exists('$(_PluginOutputPath)$(AssemblyName).deps.json')" />
    <RemoveDir Directories="$(_PluginOutputPath)runtimes" Condition="Exists('$(_PluginOutputPath)runtimes')" />

    <Message Text="[ILRepack] Assembly merging completed." Importance="high" />
  </Target>

  <!--
    MANDATORY: Inject gitSha and buildTimestamp into plugin.json

    These fields are required for artifact freshness validation:
    - gitSha: Short git commit hash (8 chars) or "unknown" if git unavailable
    - buildTimestamp: ISO 8601 UTC timestamp of when the package was built

    This target runs after RepackPlugin to ensure plugin.json in the output
    directory gets the build metadata injected before deployment or packaging.
  -->
  <Target Name="InjectPluginBuildMetadata" AfterTargets="RepackPlugin" Condition="'$(PluginPackagingDisable)' != 'true'">
    <PropertyGroup>
      <_PluginManifestPath>$(TargetDir)$(PluginManifestFileName)</_PluginManifestPath>
    </PropertyGroup>

    <!-- Get git SHA with fallback to "unknown" if git is not available -->
    <Exec Command="git rev-parse --short=8 HEAD"
          ConsoleToMsBuild="true"
          StandardOutputImportance="low"
          StandardErrorImportance="low"
          IgnoreExitCode="true"
          Condition="Exists('$(_PluginManifestPath)')">
      <Output TaskParameter="ConsoleOutput" PropertyName="_GitShaRaw" />
      <Output TaskParameter="ExitCode" PropertyName="_GitExitCode" />
    </Exec>

    <PropertyGroup>
      <!-- Use git SHA if available, otherwise "unknown" (CI without git, exported archives) -->
      <_PluginGitSha Condition="'$(_GitExitCode)' == '0' and '$(_GitShaRaw)' != ''">$(_GitShaRaw.Trim())</_PluginGitSha>
      <_PluginGitSha Condition="'$(_PluginGitSha)' == ''">unknown</_PluginGitSha>
      <!-- ISO 8601 UTC timestamp -->
      <_PluginBuildTimestamp>$([System.DateTime]::UtcNow.ToString("o"))</_PluginBuildTimestamp>
    </PropertyGroup>

    <!-- Inject gitSha and buildTimestamp into plugin.json using PowerShell (cross-platform) -->
    <Exec Command="pwsh -NoProfile -NonInteractive -Command &quot;$manifest = Get-Content -LiteralPath '$(_PluginManifestPath)' -Raw | ConvertFrom-Json; $manifest | Add-Member -NotePropertyName 'gitSha' -NotePropertyValue '$(_PluginGitSha)' -Force; $manifest | Add-Member -NotePropertyName 'buildTimestamp' -NotePropertyValue '$(_PluginBuildTimestamp)' -Force; $manifest | ConvertTo-Json -Depth 10 | Set-Content -LiteralPath '$(_PluginManifestPath)' -Encoding UTF8&quot;"
          Condition="Exists('$(_PluginManifestPath)')"
          StandardOutputImportance="low"
          IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="_PwshExitCode" />
    </Exec>

    <!-- Fallback to powershell.exe on Windows if pwsh is not available -->
    <Exec Command="powershell -NoProfile -NonInteractive -Command &quot;$manifest = Get-Content -LiteralPath '$(_PluginManifestPath)' -Raw | ConvertFrom-Json; $manifest | Add-Member -NotePropertyName 'gitSha' -NotePropertyValue '$(_PluginGitSha)' -Force; $manifest | Add-Member -NotePropertyName 'buildTimestamp' -NotePropertyValue '$(_PluginBuildTimestamp)' -Force; $manifest | ConvertTo-Json -Depth 10 | Set-Content -LiteralPath '$(_PluginManifestPath)' -Encoding UTF8&quot;"
          Condition="Exists('$(_PluginManifestPath)') and '$(_PwshExitCode)' != '0'"
          StandardOutputImportance="low"
          IgnoreExitCode="true" />

    <Message Text="[PluginPackaging] Injected build metadata: gitSha=$(_PluginGitSha), buildTimestamp=$(_PluginBuildTimestamp)" Importance="high" Condition="Exists('$(_PluginManifestPath)')" />
  </Target>

  <Target Name="DeployPluginArtifacts" AfterTargets="InjectPluginBuildMetadata" Condition="'$(EnablePluginDeployment)' == 'true' and '$(LidarrPluginDeployPath)' != ''">
    <ItemGroup>
      <PluginDeploymentFiles Include="$(OutputPath)$(PluginAssemblyFileName)" />
      <PluginDeploymentFiles Include="$(OutputPath)$(PluginSymbolFileName)" Condition="Exists('$(OutputPath)$(PluginSymbolFileName)')" />
      <PluginDeploymentFiles Include="$(OutputPath)$(PluginManifestFileName)" Condition="Exists('$(OutputPath)$(PluginManifestFileName)')" />
    </ItemGroup>

    <MakeDir Directories="$(LidarrPluginDeployPath)" />
    <Copy SourceFiles="@(PluginDeploymentFiles)"
          DestinationFiles="@(PluginDeploymentFiles->'$(LidarrPluginDeployPath)\%(Filename)%(Extension)')"
          SkipUnchangedFiles="true" />
  </Target>
</Project>
