name: E2E Bootstrap (Headless)

# Headless bootstrap CI for E2E testing with credential injection
# Runs gates against a real Lidarr instance with plugin credentials
# Always uploads diagnostics on failure for AI-assisted triage

on:
  workflow_dispatch:
    inputs:
      lidarr_tag:
        description: Lidarr Docker tag (plugins branch)
        required: true
        default: pr-plugins-3.1.1.4884
      plugins:
        description: Comma-separated plugins to test
        required: true
        default: Qobuzarr,Tidalarr,Brainarr
      run_search_gate:
        description: Run Search + AlbumSearch gates (requires indexer credentials)
        type: boolean
        required: true
        default: false
      run_grab_gate:
        description: Run Grab gate (requires indexer + download client credentials)
        type: boolean
        required: true
        default: false
      run_importlist_gate:
        description: Run ImportList gate (Brainarr LLM sync)
        type: boolean
        required: true
        default: false
      run_brainarr_llm_gate:
        description: Run Brainarr LLM functional gate (proof-of-life + sync test)
        type: boolean
        required: false
        default: false
      strict_brainarr:
        description: Fail (not skip) if LLM endpoint unreachable
        type: boolean
        required: false
        default: false
      brainarr_sync_timeout_sec:
        description: Timeout in seconds for Brainarr LLM sync (default 120, increase for slow endpoints)
        type: number
        required: false
        default: 120
      validate_metadata:
        description: Validate audio file metadata after grab (requires python3 + mutagen)
        type: boolean
        required: true
        default: false
      force_config_update:
        description: Force update all fields (blast and converge mode)
        type: boolean
        required: true
        default: false
      upload_diagnostics_on_success:
        description: Upload diagnostics bundle even on success (for debugging)
        type: boolean
        required: false
        default: false
      cold_start:
        description: Cold-start mode - fresh config dir, proves Configure gate works from scratch
        type: boolean
        required: false
        default: false
      post_restart_grab:
        description: Run full grab cycle after restart to prove tokens survive and downloads work
        type: boolean
        required: false
        default: false
      post_restart_grab_timeout_min:
        description: Timeout in minutes for post-restart grab (default 12)
        type: number
        required: false
        default: 12
      tidal_tokens_overwrite:
        description: Token overwrite behavior - auto (overwrite if expired), always (force overwrite), never (skip if exists)
        type: choice
        required: false
        default: auto
        options:
          - auto
          - always
          - never
      run_canary:
        description: Run canary job against latest pr-plugins tag (non-blocking, catches host regressions)
        type: boolean
        required: false
        default: false
      canary_level:
        description: Canary test depth (configure=fast smoke test, search=includes Search/AlbumSearch gates)
        type: choice
        required: false
        default: configure
        options:
          - configure
          - search
      use_host_override:
        description: Mount patched Lidarr.Common.dll to fix multi-plugin ALC bug (auto=enable for >1 plugin)
        type: choice
        required: false
        default: auto
        options:
          - auto
          - always
          - never
      lidarr_override_repo:
        description: Repository for patched Lidarr host (fork with ALC fix)
        type: string
        required: false
        default: RicherTunes/Lidarr
      lidarr_override_ref:
        description: Git ref for patched Lidarr host (branch/tag/sha)
        type: string
        required: false
        # Pinned SHA is recommended for deterministic builds; override as needed.
        default: 1e741479fad766584e196187c61bea302085704a

permissions:
  contents: read

env:
  DOTNET_NOLOGO: "true"
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  # Workflow inputs as env vars (safe pattern for shell usage)
  INPUT_LIDARR_TAG: ${{ inputs.lidarr_tag }}
  INPUT_PLUGINS: ${{ inputs.plugins }}
  INPUT_RUN_SEARCH_GATE: ${{ inputs.run_search_gate }}
  INPUT_RUN_GRAB_GATE: ${{ inputs.run_grab_gate }}
  INPUT_RUN_IMPORTLIST_GATE: ${{ inputs.run_importlist_gate }}
  INPUT_RUN_BRAINARR_LLM_GATE: ${{ inputs.run_brainarr_llm_gate }}
  INPUT_STRICT_BRAINARR: ${{ inputs.strict_brainarr }}
  INPUT_BRAINARR_SYNC_TIMEOUT_SEC: ${{ inputs.brainarr_sync_timeout_sec }}
  INPUT_VALIDATE_METADATA: ${{ inputs.validate_metadata }}
  INPUT_FORCE_CONFIG_UPDATE: ${{ inputs.force_config_update }}
  INPUT_COLD_START: ${{ inputs.cold_start }}
  INPUT_POST_RESTART_GRAB: ${{ inputs.post_restart_grab }}
  INPUT_POST_RESTART_GRAB_TIMEOUT_MIN: ${{ inputs.post_restart_grab_timeout_min }}
  INPUT_TIDAL_TOKENS_OVERWRITE: ${{ inputs.tidal_tokens_overwrite }}
  INPUT_CANARY_LEVEL: ${{ inputs.canary_level }}
  INPUT_USE_HOST_OVERRIDE: ${{ inputs.use_host_override }}
  INPUT_LIDARR_OVERRIDE_REPO: ${{ inputs.lidarr_override_repo }}
  INPUT_LIDARR_OVERRIDE_REF: ${{ inputs.lidarr_override_ref }}

jobs:
  bootstrap:
    name: Bootstrap
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install PowerShell
        shell: bash
        run: |
          set -euo pipefail
          if command -v pwsh >/dev/null 2>&1; then
            echo "PowerShell already installed"
            exit 0
          fi
          . /etc/os-release || true
          CODENAME=${VERSION_CODENAME:-"jammy"}
          curl -fsSL "https://packages.microsoft.com/config/ubuntu/$CODENAME/packages-microsoft-prod.deb" -o packages-microsoft-prod.deb \
            || curl -fsSL "https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb" -o packages-microsoft-prod.deb
          sudo dpkg -i packages-microsoft-prod.deb
          sudo apt-get update
          sudo apt-get install -y powershell

      # =========================================================================
      # PRE-FLIGHT: Redaction Self-Test
      # Ensures secrets won't leak in diagnostics bundles before we proceed
      # =========================================================================
      - name: Redaction self-test
        shell: pwsh
        run: |
          Import-Module "$env:GITHUB_WORKSPACE/scripts/lib/e2e-diagnostics.psm1" -Force
          try {
            $result = Test-SecretRedaction
            if ($result) {
              Write-Host "PASS: Redaction self-test passed" -ForegroundColor Green
            } else {
              throw "Redaction self-test returned false"
            }
          } catch {
            Write-Host "FAIL: Redaction self-test failed: $_" -ForegroundColor Red
            Write-Host "Refusing to run gates until redaction is fixed." -ForegroundColor Yellow
            exit 1
          }

      # =========================================================================
      # PREFLIGHT: Validate required secrets are present
      # =========================================================================
      - name: Validate secrets
        shell: bash
        env:
          # Qobuzarr credentials (masked automatically by GitHub)
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          # Tidalarr credentials
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_CONFIG_PATH: ${{ secrets.TIDALARR_CONFIG_PATH }}
          TIDALARR_TOKENS_JSON_B64: ${{ secrets.TIDALARR_TOKENS_JSON_B64 }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          # Brainarr credentials
          BRAINARR_LLM_BASE_URL: ${{ secrets.BRAINARR_LLM_BASE_URL }}
          # Cross-repo PAT for private plugin repos
          CROSS_REPO_PAT: ${{ secrets.CROSS_REPO_PAT }}
        run: |
          set -euo pipefail

          # Mask secrets explicitly (GitHub does this, but belt-and-suspenders)
          echo "::add-mask::${QOBUZARR_AUTH_TOKEN:-}"
          echo "::add-mask::${QOBUZ_AUTH_TOKEN:-}"
          echo "::add-mask::${TIDALARR_REDIRECT_URL:-}"
          echo "::add-mask::${TIDAL_REDIRECT_URL:-}"
          echo "::add-mask::${TIDALARR_TOKENS_JSON_B64:-}"
          echo "::add-mask::${BRAINARR_LLM_BASE_URL:-}"
          echo "::add-mask::${CROSS_REPO_PAT:-}"

          # Check CROSS_REPO_PAT (required for private plugin repos)
          if [[ -z "${CROSS_REPO_PAT:-}" ]]; then
            echo "::error::CROSS_REPO_PAT secret is required to checkout private plugin repos"
            exit 1
          fi

          # Check plugin-specific credentials based on which gates are enabled
          if [[ "$INPUT_RUN_SEARCH_GATE" == "true" || "$INPUT_RUN_GRAB_GATE" == "true" ]]; then
            # Check Qobuzarr credentials
            if [[ "$INPUT_PLUGINS" == *"Qobuzarr"* ]]; then
              has_qobuz=false
              if [[ -n "${QOBUZARR_AUTH_TOKEN:-}" || -n "${QOBUZ_AUTH_TOKEN:-}" ]]; then
                has_qobuz=true
              fi
              if [[ "$has_qobuz" != "true" ]]; then
                echo "::warning::Qobuzarr credentials missing - Qobuzarr gates will SKIP"
              fi
            fi

            # Check Tidalarr credentials
            if [[ "$INPUT_PLUGINS" == *"Tidalarr"* ]]; then
              has_tidal=false
              # Seeded tokens (TIDALARR_TOKENS_JSON_B64) OR OAuth redirect URL allows gates to run
              if [[ -n "${TIDALARR_TOKENS_JSON_B64:-}" ]]; then
                has_tidal=true
                echo "::notice::Tidalarr using seeded tokens (TIDALARR_TOKENS_JSON_B64)"
              elif [[ -n "${TIDALARR_REDIRECT_URL:-}" || -n "${TIDAL_REDIRECT_URL:-}" || -n "${TIDALARR_CONFIG_PATH:-}" ]]; then
                has_tidal=true
              fi
              if [[ "$has_tidal" != "true" ]]; then
                echo "::warning::Tidalarr credentials missing - Tidalarr gates will SKIP"
              fi
            fi
          fi

          # Check Brainarr credentials for ImportList gate
          if [[ "$INPUT_RUN_IMPORTLIST_GATE" == "true" && "$INPUT_PLUGINS" == *"Brainarr"* ]]; then
            if [[ -z "${BRAINARR_LLM_BASE_URL:-}" ]]; then
              echo "::warning::BRAINARR_LLM_BASE_URL missing - Brainarr ImportList gate will SKIP"
            fi
          fi

          echo "Secret validation complete"

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Checkout Qobuzarr
        if: contains(inputs.plugins, 'Qobuzarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Qobuzarr
          ref: main
          path: qobuzarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Tidalarr
        if: contains(inputs.plugins, 'Tidalarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Tidalarr
          ref: main
          path: tidalarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Brainarr
        if: contains(inputs.plugins, 'Brainarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Brainarr
          ref: main
          path: brainarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      # =========================================================================
      # HOST OVERRIDE: Build patched Lidarr.Common.dll to fix multi-plugin ALC bug
      # This is only used when multiple plugins are tested (or explicitly enabled)
      # =========================================================================
      - name: Determine host override mode
        id: host-override
        shell: bash
        run: |
          set -euo pipefail

          # Count plugins (ignore empty/whitespace entries).
          plugin_count=$(printf '%s' "${INPUT_PLUGINS:-}" | tr ',' '\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed '/^$/d' | wc -l | tr -d ' ')
          echo "Plugin count: $plugin_count"

          # Determine if host override should be enabled
          use_override="false"
          override_reason=""

          case "${INPUT_USE_HOST_OVERRIDE:-auto}" in
            always)
              use_override="true"
              override_reason="explicitly enabled via input"
              ;;
            never)
              use_override="false"
              override_reason="explicitly disabled via input"
              ;;
            auto|*)
              if [ "$plugin_count" -gt 1 ]; then
                use_override="true"
                override_reason="auto-enabled for multi-plugin ($plugin_count plugins)"
              else
                use_override="false"
                override_reason="auto-disabled for single plugin"
              fi
              ;;
          esac

          echo "USE_HOST_OVERRIDE=$use_override" >> $GITHUB_ENV
          echo "HOST_OVERRIDE_REASON=$override_reason" >> $GITHUB_ENV
          echo "use_override=$use_override" >> $GITHUB_OUTPUT

          if [ "$use_override" = "true" ]; then
            echo "::notice::Host override ENABLED: $override_reason"
          else
            echo "Host override disabled: $override_reason"
          fi

      - name: Cache host override DLL
        if: steps.host-override.outputs.use_override == 'true'
        id: cache-host-override
        uses: actions/cache@v4
        with:
          # Cache includes both DLL and its SHA256 checksum for verification
          path: |
            _host_override_Lidarr.Common.dll
            _host_override_Lidarr.Common.dll.sha256
          # Key includes: ref (source), OS, and .NET SDK version (build environment)
          # This prevents cache poisoning from SDK version changes
          key: host-override-${{ inputs.lidarr_override_ref || '1e741479fad766584e196187c61bea302085704a' }}-${{ runner.os }}-dotnet${{ env.DOTNET_VERSION || '8.0' }}

      - name: Checkout patched Lidarr host
        if: steps.host-override.outputs.use_override == 'true' && steps.cache-host-override.outputs.cache-hit != 'true'
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.lidarr_override_repo || 'RicherTunes/Lidarr' }}
          ref: ${{ inputs.lidarr_override_ref || '1e741479fad766584e196187c61bea302085704a' }}
          path: _lidarr_host_override
          token: ${{ secrets.CROSS_REPO_PAT || github.token }}

      - name: Build patched Lidarr.Common.dll
        if: steps.host-override.outputs.use_override == 'true' && steps.cache-host-override.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Building patched Lidarr.Common.dll"

          cd _lidarr_host_override

          # Record the exact commit SHA for manifest traceability
          OVERRIDE_SHA=$(git rev-parse HEAD)
          echo "HOST_OVERRIDE_SHA=$OVERRIDE_SHA" >> $GITHUB_ENV
          echo "Building from commit: $OVERRIDE_SHA"

          # Build only NzbDrone.Common (produces Lidarr.Common.dll)
          # -p:RunAnalyzers=false speeds up build and avoids analyzer issues
          dotnet build src/NzbDrone.Common/Lidarr.Common.csproj \
            -c Release \
            -p:RunAnalyzers=false \
            --no-restore || dotnet build src/NzbDrone.Common/Lidarr.Common.csproj \
            -c Release \
            -p:RunAnalyzers=false

          # Locate the built runtime DLL
          # Lidarr uses shared _output/ folder, not per-project bin/ folders
          # Priority: _output/net8.0 (Lidarr convention) > bin/Release (standard)
          OVERRIDE_DLL=""
          for search_path in "_output/net8.0" "src/NzbDrone.Common/bin/Release"; do
            if [ -d "$search_path" ]; then
              candidate=$(find "$search_path" -name "Lidarr.Common.dll" -type f 2>/dev/null | head -1)
              if [ -n "$candidate" ] && [ -f "$candidate" ]; then
                OVERRIDE_DLL="$candidate"
                break
              fi
            fi
          done

          if [ -z "$OVERRIDE_DLL" ] || [ ! -f "$OVERRIDE_DLL" ]; then
            echo "::error::Failed to locate built Lidarr.Common.dll"
            echo "Searched: _output/net8.0, src/NzbDrone.Common/bin/Release"
            find . -name "Lidarr.Common.dll" -type f 2>/dev/null || true
            exit 1
          fi

          echo "Built DLL: $OVERRIDE_DLL"
          ls -la "$OVERRIDE_DLL"

          # Copy to workspace root for container mount (and caching)
          cp "$OVERRIDE_DLL" "$GITHUB_WORKSPACE/_host_override_Lidarr.Common.dll"

          # Generate SHA256 checksum file for cache integrity verification
          DLL_SHA256=$(sha256sum "$GITHUB_WORKSPACE/_host_override_Lidarr.Common.dll" | cut -d' ' -f1)
          echo "$DLL_SHA256" > "$GITHUB_WORKSPACE/_host_override_Lidarr.Common.dll.sha256"
          echo "Generated checksum: $DLL_SHA256"

          echo "::endgroup::"
          echo "::notice::Patched Lidarr.Common.dll built successfully from $OVERRIDE_SHA"

      - name: Configure host override DLL
        if: steps.host-override.outputs.use_override == 'true'
        shell: bash
        run: |
          set -euo pipefail

          DLL_PATH="$GITHUB_WORKSPACE/_host_override_Lidarr.Common.dll"
          CHECKSUM_PATH="$GITHUB_WORKSPACE/_host_override_Lidarr.Common.dll.sha256"

          if [ ! -f "$DLL_PATH" ]; then
            echo "::error::Host override DLL not found at $DLL_PATH"
            exit 1
          fi

          echo "HOST_OVERRIDE_DLL_PATH=$DLL_PATH" >> $GITHUB_ENV

          # Calculate SHA256 for forensics and reproducibility
          DLL_SHA256=$(sha256sum "$DLL_PATH" | cut -d' ' -f1)
          echo "HOST_OVERRIDE_DLL_SHA256=$DLL_SHA256" >> $GITHUB_ENV

          # Verify checksum integrity for cached builds
          CACHE_HIT="${{ steps.cache-host-override.outputs.cache-hit }}"
          if [ "$CACHE_HIT" = "true" ] && [ -f "$CHECKSUM_PATH" ]; then
            EXPECTED_SHA256=$(cat "$CHECKSUM_PATH" | tr -d '[:space:]')
            if [ "$DLL_SHA256" != "$EXPECTED_SHA256" ]; then
              echo "::error::Cache integrity check FAILED!"
              echo "::error::Expected: $EXPECTED_SHA256"
              echo "::error::Got:      $DLL_SHA256"
              echo "::error::This may indicate cache poisoning. Failing build."
              exit 1
            fi
            echo "✓ Cache integrity verified (sha256 matches)"
          fi

          # Set override SHA (from build or from input ref for cached builds)
          if [ -z "${HOST_OVERRIDE_SHA:-}" ]; then
            # Cached build - use the input ref as the SHA identifier
            OVERRIDE_REF="${{ inputs.lidarr_override_ref || '1e741479fad766584e196187c61bea302085704a' }}"
            echo "HOST_OVERRIDE_SHA=$OVERRIDE_REF" >> $GITHUB_ENV
            echo "::notice::Using cached host override DLL (ref: $OVERRIDE_REF, sha256: ${DLL_SHA256:0:16}...)"
          else
            echo "::notice::Built host override DLL (sha: $HOST_OVERRIDE_SHA, sha256: ${DLL_SHA256:0:16}...)"
          fi

      - name: Pull Lidarr Docker image
        id: pull-image
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/hotio/lidarr:${INPUT_LIDARR_TAG}"
          echo "Pulling $IMAGE..."

          n=0
          until [ "$n" -ge 3 ]; do
            docker pull "$IMAGE" && break
            n=$((n+1))
            echo "Pull failed ($n/3). Retrying in 10s..." && sleep 10
          done

          if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -qF "ghcr.io/hotio/lidarr:${INPUT_LIDARR_TAG}"; then
            echo "::error::Failed to pull Docker image after 3 attempts"
            exit 1
          fi

          # Extract immutable image digest for cache keying (tags are mutable!)
          # Format: ghcr.io/hotio/lidarr@sha256:abc123...
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || echo "")
          if [ -n "$IMAGE_DIGEST" ]; then
            # Extract just the sha256 hash for cache key (shorter, still unique)
            DIGEST_HASH=$(echo "$IMAGE_DIGEST" | sed 's/.*@sha256://')
            echo "LIDARR_IMAGE_DIGEST=$DIGEST_HASH" >> $GITHUB_ENV
            echo "image_digest=$DIGEST_HASH" >> $GITHUB_OUTPUT
            echo "::notice::Image digest: ${DIGEST_HASH:0:12}..."
          else
            # Fallback to tag if digest unavailable (local builds, etc)
            echo "LIDARR_IMAGE_DIGEST=$INPUT_LIDARR_TAG" >> $GITHUB_ENV
            echo "image_digest=$INPUT_LIDARR_TAG" >> $GITHUB_OUTPUT
            echo "::warning::Could not extract image digest, using tag as fallback"
          fi

      - name: Cache Lidarr assemblies
        id: cache-lidarr-assemblies
        uses: actions/cache@v4
        with:
          path: _lidarr_assemblies
          # Use image digest (immutable) instead of tag (mutable) to prevent cache poisoning
          key: lidarr-assemblies-${{ steps.pull-image.outputs.image_digest }}-${{ runner.os }}

      - name: Extract Lidarr assemblies
        if: steps.cache-lidarr-assemblies.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/hotio/lidarr:${INPUT_LIDARR_TAG}"

          echo "Creating temporary container..."
          cid=$(docker create "$IMAGE")

          echo "Extracting assemblies..."
          mkdir -p _lidarr_extracted
          docker cp "$cid:/app" _lidarr_extracted/ 2>/dev/null || docker cp "$cid:/opt/lidarr" _lidarr_extracted/ 2>/dev/null || {
            echo "::error::Could not extract from /app or /opt/lidarr"
            docker rm "$cid" >/dev/null
            exit 1
          }
          docker rm "$cid" >/dev/null

          # Copy extracted DLLs to cache directory
          mkdir -p _lidarr_assemblies
          find _lidarr_extracted -type f -name "*.dll" -exec cp {} _lidarr_assemblies/ \;
          rm -rf _lidarr_extracted
          echo "Assembly extraction complete ($(ls _lidarr_assemblies | wc -l) DLLs)"

      - name: Copy Lidarr assemblies to plugins
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d "_lidarr_assemblies" ] || [ -z "$(ls -A _lidarr_assemblies 2>/dev/null)" ]; then
            echo "::error::Lidarr assemblies directory is empty or missing"
            exit 1
          fi

          # Copy to plugin ext directories
          for plugin_dir in qobuzarr tidalarr brainarr; do
            if [ -d "$plugin_dir" ]; then
              mkdir -p "$plugin_dir/ext/Lidarr/_output/net8.0"
              cp _lidarr_assemblies/*.dll "$plugin_dir/ext/Lidarr/_output/net8.0/"
              echo "Copied assemblies to $plugin_dir/ext/Lidarr/_output/net8.0/"
            fi
          done

      - name: Sync tools to plugin submodules
        shell: bash
        run: |
          set -euo pipefail
          for plugin_dir in qobuzarr tidalarr brainarr; do
            submod="$plugin_dir/ext/Lidarr.Plugin.Common"
            if [ -d "$submod" ]; then
              echo "Syncing tools to $submod..."
              [ -d "tools" ] && rm -rf "$submod/tools" && cp -r tools "$submod/tools"
              [ -d "build" ] && rm -rf "$submod/build" && cp -r build "$submod/build"
              [ -d "scripts" ] && rm -rf "$submod/scripts" && cp -r scripts "$submod/scripts"
            fi
          done

      - name: Build plugin packages
        shell: pwsh
        run: |
          $plugins = $env:INPUT_PLUGINS -split ','

          foreach ($plugin in $plugins) {
            $pluginLower = $plugin.Trim().ToLower()
            $pluginDir = "./$pluginLower"

            if (-not (Test-Path $pluginDir)) {
              Write-Host "::warning::Plugin directory $pluginDir not found, skipping build"
              continue
            }

            Write-Host "Building $plugin..." -ForegroundColor Cyan
            Push-Location $pluginDir
            try {
              if (Test-Path "build.ps1") {
                ./build.ps1 -Configuration Release -Restore -Package
              } else {
                Import-Module "../tools/PluginPack.psm1" -Force
                $csproj = Get-ChildItem -Filter "*.csproj" | Where-Object { $_.Name -notmatch "Tests" } | Select-Object -First 1
                if ($csproj) {
                  New-PluginPackage -Csproj $csproj.Name -Manifest "plugin.json" -MergeAssemblies -Framework "net8.0" -Configuration Release
                }
              }
              if ($LASTEXITCODE -ne 0) { throw "$plugin build failed" }
            } finally {
              Pop-Location
            }
          }

      - name: Locate plugin zips and create manifest
        id: locate-plugins
        shell: pwsh
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          $manifest = @{
            timestamp = (Get-Date -Format "o")
            run_id = $env:GITHUB_RUN_ID
            lidarr_tag = $env:INPUT_LIDARR_TAG
            plugins = @{}
            gates = @{
              search = $env:INPUT_RUN_SEARCH_GATE -eq "true"
              grab = $env:INPUT_RUN_GRAB_GATE -eq "true"
              importlist = $env:INPUT_RUN_IMPORTLIST_GATE -eq "true"
              validate_metadata = $env:INPUT_VALIDATE_METADATA -eq "true"
              force_config_update = $env:INPUT_FORCE_CONFIG_UPDATE -eq "true"
            }
          }

          function Find-PluginZip {
            param([string]$PluginDir, [string]$Pattern)
            $zips = Get-ChildItem -Path $PluginDir -Recurse -Filter "*.zip" -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' -and $_.Name -match $Pattern } |
              Sort-Object LastWriteTimeUtc -Descending
            return $zips | Select-Object -First 1
          }

          $plugins = $env:INPUT_PLUGINS -split ','
          $pluginZips = @()

          foreach ($plugin in $plugins) {
            $pluginName = $plugin.Trim()
            $pluginDir = "./$($pluginName.ToLower())"

            if (Test-Path $pluginDir) {
              $zip = Find-PluginZip -PluginDir $pluginDir -Pattern $pluginName
              if ($zip) {
                $pluginZips += "$pluginName=$($zip.FullName)"
                $manifest.plugins[$pluginName] = @{
                  zip = $zip.FullName
                  size = $zip.Length
                }
                Write-Host "$pluginName zip: $($zip.FullName)"
              } else {
                Write-Host "::warning::No zip found for $pluginName"
              }
            }
          }

          # Save manifest
          $manifest | ConvertTo-Json -Depth 5 | Set-Content -Path "run-manifest.json"

          # Export for later steps
          $pluginZipList = $pluginZips -join ","
          "PLUGIN_ZIPS=$pluginZipList" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      # =========================================================================
      # COLD-START CLEANUP: Remove stale config-cold-* directories
      # Safety: Only deletes under .e2e-bootstrap/ with config-cold- prefix
      # =========================================================================
      - name: Cleanup stale cold-start configs
        shell: bash
        run: |
          # Clean up any leftover cold-start config directories from previous runs
          # SAFETY: Anchored to .e2e-bootstrap/ and requires config-cold- prefix
          BASE_DIR=".e2e-bootstrap"
          if [ -d "$BASE_DIR" ]; then
            # Double-check we're in the right place
            if [[ "$(pwd)" != *".e2e-bootstrap"* ]]; then
              old_count=$(find "$BASE_DIR" -maxdepth 1 -type d -name 'config-cold-*' 2>/dev/null | wc -l)
              if [ "$old_count" -gt 0 ]; then
                echo "Removing $old_count stale cold-start config directories..."
                # Only remove directories matching exact pattern under BASE_DIR
                find "$BASE_DIR" -maxdepth 1 -type d -name 'config-cold-*' -exec rm -rf {} + 2>/dev/null || true
              fi
            fi
          fi

      # =========================================================================
      # TIDAL SEEDED TOKENS: Decode to staging area (actual deploy is after CONFIG_DIR is set)
      # This runs BEFORE container start to validate B64 early. The staging file is copied
      # to the correct CONFIG_DIR path in the container start step (supports cold-start mode).
      # Uses PowerShell for cross-platform base64 decode (works on Linux, Windows, macOS).
      # =========================================================================
      - name: Stage Tidal tokens (if provided)
        if: contains(inputs.plugins, 'Tidalarr')
        shell: pwsh
        env:
          TIDALARR_TOKENS_JSON_B64: ${{ secrets.TIDALARR_TOKENS_JSON_B64 }}
        run: |
          $ErrorActionPreference = 'Stop'

          $stagingFile = ".e2e-bootstrap/tidal_tokens_staging.json"

          # Record overwrite mode for manifest
          $overwriteMode = if ($env:INPUT_TIDAL_TOKENS_OVERWRITE) { $env:INPUT_TIDAL_TOKENS_OVERWRITE } else { "auto" }
          "TIDAL_TOKEN_SEED_OVERWRITE_MODE=$overwriteMode" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          # No tokens provided - record reason and explicit error code
          if ([string]::IsNullOrEmpty($env:TIDALARR_TOKENS_JSON_B64)) {
            "TIDAL_TOKEN_SEED_STATUS=skipped" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_REASON=no_secret_provided" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_MISSING_SECRET" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host "::notice::Tidal token seeding skipped (TIDALARR_TOKENS_JSON_B64 not set)"
            exit 0
          }

          # Mask the B64 string (GitHub should already do this, but belt-and-suspenders)
          Write-Host "::add-mask::$($env:TIDALARR_TOKENS_JSON_B64)"

          # Ensure directory exists
          $stagingDir = Split-Path $stagingFile -Parent
          if (-not (Test-Path $stagingDir)) {
            New-Item -ItemType Directory -Path $stagingDir -Force | Out-Null
          }

          # Decode base64 using cross-platform .NET method - NEVER echo decoded content
          try {
            $decodedBytes = [System.Convert]::FromBase64String($env:TIDALARR_TOKENS_JSON_B64)
            $decodedJson = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
          } catch {
            "TIDAL_TOKEN_SEED_STATUS=failed" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_REASON=invalid_base64" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_INVALID_BASE64" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host "::error::TIDALARR_TOKENS_JSON_B64 contains invalid base64: $_"
            exit 1
          }

          # Validate it's valid JSON (basic sanity check)
          try {
            $null = $decodedJson | ConvertFrom-Json -ErrorAction Stop
          } catch {
            "TIDAL_TOKEN_SEED_STATUS=failed" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_REASON=invalid_json" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_INVALID_JSON" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host "::error::Decoded TIDALARR_TOKENS_JSON_B64 is not valid JSON: $_"
            exit 1
          }

          # Write to staging file (UTF8 without BOM for JSON compatibility)
          try {
            [System.IO.File]::WriteAllText($stagingFile, $decodedJson, [System.Text.UTF8Encoding]::new($false))
          } catch {
            "TIDAL_TOKEN_SEED_STATUS=failed" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_REASON=io_error" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_IO_ERROR" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            Write-Host "::error::Failed to write staging file: $_"
            exit 1
          }

          # Report success without revealing content
          $bytes = (Get-Item $stagingFile).Length
          "TIDAL_TOKEN_SEED_STATUS=staged" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "TIDAL_TOKEN_SEED_STAGING_PATH=$stagingFile" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "TIDAL_TOKEN_SEED_BYTES=$bytes" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          Write-Host "::notice::Tidal tokens staged ($bytes bytes), will deploy after CONFIG_DIR is set"

      - name: Start Lidarr container
        id: start-container
        shell: bash
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_RUN_ATTEMPT: ${{ github.run_attempt }}
        run: |
          set -euo pipefail

          CONTAINER_NAME="lidarr-e2e-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}"
          echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV

          # Cold-start mode: use unique GUID-based config to prove Configure gate works from scratch
          if [[ "${INPUT_COLD_START:-false}" == "true" ]]; then
            CONFIG_GUID=$(uuidgen | tr -d '-' | head -c 12)
            CONFIG_DIR=".e2e-bootstrap/config-cold-${CONFIG_GUID}"
            echo "::notice::COLD-START MODE: Using fresh config dir $CONFIG_DIR"
            echo "E2E_COLD_START=true" >> $GITHUB_ENV
            echo "E2E_CONFIG_DIR=$CONFIG_DIR" >> $GITHUB_ENV
            # Salt preferred-ID state by cold-start GUID to avoid cross-instance collisions
            echo "E2E_COMPONENT_IDS_INSTANCE_SALT=$CONFIG_GUID" >> $GITHUB_ENV
          else
            CONFIG_DIR=".e2e-bootstrap/config"
            echo "E2E_COLD_START=false" >> $GITHUB_ENV
            echo "E2E_CONFIG_DIR=$CONFIG_DIR" >> $GITHUB_ENV
          fi

          # Create directories (fresh for cold-start, reused otherwise)
          #
          # IMPORTANT: Lidarr expects plugins under /config/plugins/<Vendor>/<PluginName>/.
          # Our vendor folder is "RicherTunes" (matches local persistent runner conventions).
          mkdir -p "$CONFIG_DIR/plugins/RicherTunes" .e2e-bootstrap/downloads

          # ============================================================================
          # PRE-SEED: Extract plugins to config dir BEFORE container starts
          # This ensures Lidarr sees plugins at first boot (deterministic loading)
          # Each plugin gets its own subdirectory to avoid file collisions
          # ============================================================================
          echo "::group::Pre-seed plugins to $CONFIG_DIR/plugins/"
          IFS=',' read -ra ZIPS <<< "$PLUGIN_ZIPS"
          for entry in "${ZIPS[@]}"; do
            plugin_name="${entry%%=*}"
            zip_path="${entry#*=}"
            if [ -f "$zip_path" ]; then
              # Each plugin in its own subdirectory under the vendor folder:
              # plugins/RicherTunes/Qobuzarr/, plugins/RicherTunes/Tidalarr/, etc.
              plugin_dir="$CONFIG_DIR/plugins/RicherTunes/$plugin_name"
              mkdir -p "$plugin_dir"
              echo "Extracting $plugin_name from $zip_path to $plugin_dir..."
              unzip -o "$zip_path" -d "$plugin_dir"
              echo "  ✓ $plugin_name extracted"
            else
              echo "::warning::Plugin zip not found: $zip_path"
            fi
          done
          echo "::endgroup::"

          # ============================================================================
          # DEPLOY TIDAL TOKENS: Copy staged tokens to correct CONFIG_DIR path
          # This happens AFTER CONFIG_DIR is determined, so cold-start works correctly.
          # Overwrite modes: auto (if expired), always (force), never (skip if exists)
          # ============================================================================
          if [[ "${TIDAL_TOKEN_SEED_STATUS:-}" == "staged" ]]; then
            STAGING_FILE="${TIDAL_TOKEN_SEED_STAGING_PATH:-.e2e-bootstrap/tidal_tokens_staging.json}"
            TARGET_DIR="$CONFIG_DIR/plugins/RicherTunes/Tidalarr"
            TARGET_FILE="$TARGET_DIR/tidal_tokens.json"
            OVERWRITE_MODE="${INPUT_TIDAL_TOKENS_OVERWRITE:-auto}"

            mkdir -p "$TARGET_DIR"

            # Determine if we should deploy based on overwrite mode
            SHOULD_DEPLOY="false"
            DEPLOY_REASON=""

            if [[ ! -f "$TARGET_FILE" ]]; then
              # No existing file - always deploy
              SHOULD_DEPLOY="true"
              DEPLOY_REASON="no_existing_file"
            elif [[ "$OVERWRITE_MODE" == "always" ]]; then
              # Force overwrite mode
              SHOULD_DEPLOY="true"
              DEPLOY_REASON="force_overwrite"
              echo "::notice::Overwriting existing tokens (mode=always)"
            elif [[ "$OVERWRITE_MODE" == "never" ]]; then
              # Never overwrite mode
              SHOULD_DEPLOY="false"
              echo "::notice::Tidal tokens already exist, skipping (mode=never)"
              echo "TIDAL_TOKEN_SEED_STATUS=skipped" >> $GITHUB_ENV
              echo "TIDAL_TOKEN_SEED_REASON=file_exists" >> $GITHUB_ENV
              rm -f "$STAGING_FILE"
            else
              # Auto mode: check token freshness
              # Try to extract expires_at or expiresAt from existing tokens
              # Handles both epoch seconds (int) and ISO 8601 strings (UTC)
              EXPIRY_RESULT=""
              if command -v python3 &>/dev/null; then
                EXPIRY_RESULT=$(python3 -c "
import json, sys
from datetime import datetime, timezone
try:
    with open('$TARGET_FILE') as f:
        tokens = json.load(f)
    # Try common expiry field names
    exp = tokens.get('expires_at') or tokens.get('expiresAt') or tokens.get('expiry') or tokens.get('expires')
    if exp is None:
        print('no_field')
        sys.exit(0)

    now_utc = datetime.now(timezone.utc).timestamp()
    buffer = 3600  # 1 hour

    # Handle epoch seconds (int or numeric string)
    try:
        exp_epoch = int(exp)
        if exp_epoch <= (now_utc + buffer):
            print('expired')
        else:
            print('valid')
        sys.exit(0)
    except (ValueError, TypeError):
        pass

    # Handle ISO 8601 string (assume UTC if no timezone)
    try:
        # Try parsing ISO format
        if isinstance(exp, str):
            # Handle both 'Z' suffix and '+00:00'
            exp_str = exp.replace('Z', '+00:00')
            if '+' not in exp_str and '-' not in exp_str[10:]:
                # No timezone - assume UTC
                exp_str += '+00:00'
            exp_dt = datetime.fromisoformat(exp_str)
            exp_epoch = exp_dt.timestamp()
            if exp_epoch <= (now_utc + buffer):
                print('expired')
            else:
                print('valid')
            sys.exit(0)
    except (ValueError, TypeError):
        pass

    # Could not parse
    print('parse_error')
except Exception as e:
    print(f'error:{e}')
" 2>/dev/null || echo "error:python_failed")
              else
                EXPIRY_RESULT="error:no_python"
              fi

              case "$EXPIRY_RESULT" in
                expired)
                  SHOULD_DEPLOY="true"
                  DEPLOY_REASON="token_expired"
                  echo "::warning::Existing tokens expired or near expiry, overwriting"
                  ;;
                valid)
                  SHOULD_DEPLOY="false"
                  echo "::notice::Existing tokens still valid, skipping"
                  echo "TIDAL_TOKEN_SEED_STATUS=skipped" >> $GITHUB_ENV
                  echo "TIDAL_TOKEN_SEED_REASON=token_still_valid" >> $GITHUB_ENV
                  rm -f "$STAGING_FILE"
                  ;;
                no_field)
                  SHOULD_DEPLOY="true"
                  DEPLOY_REASON="no_expiry_field"
                  echo "::notice::No expiry field in existing tokens, overwriting to be safe"
                  ;;
                parse_error)
                  SHOULD_DEPLOY="true"
                  DEPLOY_REASON="expiry_unknown"
                  echo "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_EXPIRY_PARSE_ERROR" >> $GITHUB_ENV
                  echo "::warning::Could not parse token expiry format, overwriting to be safe"
                  ;;
                *)
                  # Any error - be safe and overwrite
                  SHOULD_DEPLOY="true"
                  DEPLOY_REASON="expiry_unknown"
                  echo "::notice::Could not determine token expiry ($EXPIRY_RESULT), overwriting to be safe"
                  ;;
              esac
            fi

            if [[ "$SHOULD_DEPLOY" == "true" ]]; then
              # Copy from staging to final location
              if ! cp "$STAGING_FILE" "$TARGET_FILE" 2>/dev/null; then
                echo "TIDAL_TOKEN_SEED_STATUS=failed" >> $GITHUB_ENV
                echo "TIDAL_TOKEN_SEED_REASON=io_error" >> $GITHUB_ENV
                echo "TIDAL_TOKEN_SEED_ERROR_CODE=E2E_TOKEN_SEED_IO_ERROR" >> $GITHUB_ENV
                echo "::error::Failed to copy tokens to target location"
                exit 1
              fi
              chmod 600 "$TARGET_FILE"
              rm -f "$STAGING_FILE"

              # Record seededAtUtc timestamp (ISO 8601)
              SEEDED_AT_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

              BYTES=$(wc -c < "$TARGET_FILE")
              echo "TIDAL_TOKEN_SEED_STATUS=deployed" >> $GITHUB_ENV
              echo "TIDAL_TOKEN_SEED_REASON=$DEPLOY_REASON" >> $GITHUB_ENV
              echo "TIDALARR_SEEDED_TOKENS_PATH=$TARGET_FILE" >> $GITHUB_ENV
              echo "TIDAL_TOKEN_SEED_TARGET_PATH_KIND=configPath" >> $GITHUB_ENV
              echo "TIDAL_TOKEN_SEED_SEEDED_AT_UTC=$SEEDED_AT_UTC" >> $GITHUB_ENV
              echo "::notice::Tidal tokens deployed to $TARGET_FILE ($BYTES bytes, reason=$DEPLOY_REASON)"
            fi
          elif [[ "${TIDAL_TOKEN_SEED_STATUS:-}" == "skipped" ]]; then
            echo "Tidal token seeding was skipped: ${TIDAL_TOKEN_SEED_REASON:-unknown}"
          elif [[ "${TIDAL_TOKEN_SEED_STATUS:-}" == "failed" ]]; then
            echo "::error::Tidal token seeding failed: ${TIDAL_TOKEN_SEED_REASON:-unknown}"
            exit 1
          fi

          # Verify plugins exist before startup (hard check)
          echo "::group::Verify pre-seeded plugins"
          plugin_count=$(find "$CONFIG_DIR/plugins/RicherTunes" -name "plugin.json" -type f 2>/dev/null | wc -l)
          if [ "$plugin_count" -eq 0 ]; then
            echo "::error::No plugin.json files found in $CONFIG_DIR/plugins/RicherTunes/ - pre-seed failed!"
            ls -laR "$CONFIG_DIR/plugins/" || true
            exit 1
          fi
          echo "Found $plugin_count plugin(s) with plugin.json:"
          find "$CONFIG_DIR/plugins/RicherTunes" -name "plugin.json" -type f
          echo ""
          echo "Expected plugin.json locations:"
          for entry in "${ZIPS[@]}"; do
            plugin_name="${entry%%=*}"
            expected="$CONFIG_DIR/plugins/RicherTunes/$plugin_name/plugin.json"
            if [ -f "$expected" ]; then
              echo "  ✓ $expected"
            else
              echo "::error::Missing expected plugin.json: $expected"
              exit 1
            fi
          done
          echo ""
          echo "Pre-seeded plugin directory contents:"
          ls -laR "$CONFIG_DIR/plugins/"
          echo "::endgroup::"

          # Save host-side plugin listing for diagnostics (proves plugins existed before startup)
          mkdir -p .e2e-bootstrap/diagnostics
          find "$CONFIG_DIR/plugins" -type f > .e2e-bootstrap/diagnostics/host-plugins-pre-start.txt
          echo "PRE_START_PLUGIN_LISTING=$(pwd)/.e2e-bootstrap/diagnostics/host-plugins-pre-start.txt" >> $GITHUB_ENV

          # Build docker run arguments
          DOCKER_ARGS=(
            -d
            --name "$CONTAINER_NAME"
            -p 8686:8686
            -v "$(pwd)/${CONFIG_DIR}:/config"
            -v "$(pwd)/.e2e-bootstrap/downloads:/downloads"
            -e PUID=1000
            -e PGID=1000
          )

          # Conditionally add host override mount
          if [[ "${USE_HOST_OVERRIDE:-false}" == "true" ]] && [ -f "${HOST_OVERRIDE_DLL_PATH:-}" ]; then
            echo "::notice::Mounting patched Lidarr.Common.dll from $HOST_OVERRIDE_DLL_PATH"
            DOCKER_ARGS+=(-v "${HOST_OVERRIDE_DLL_PATH}:/app/bin/Lidarr.Common.dll:ro")
            echo "E2E_HOST_OVERRIDE_MOUNTED=true" >> $GITHUB_ENV
          else
            echo "E2E_HOST_OVERRIDE_MOUNTED=false" >> $GITHUB_ENV
          fi

          # Start container with plugins already in place (no post-start deployment needed)
          docker run "${DOCKER_ARGS[@]}" "ghcr.io/hotio/lidarr:${INPUT_LIDARR_TAG}"

          echo "Waiting for Lidarr to start (plugins pre-seeded, no restart needed)..."

          # Wait for API (extended timeout since no restart)
          n=0
          until [ "$n" -ge 45 ]; do
            if curl -s "http://localhost:8686/api/v1/system/status" >/dev/null 2>&1; then
              echo "✓ Lidarr API is ready"
              break
            fi
            n=$((n+1))
            echo "Waiting for API ($n/45)..."
            sleep 2
          done

          if [ "$n" -ge 45 ]; then
            echo "::error::Lidarr API failed to become ready after 90 seconds"
            docker logs "$CONTAINER_NAME" --tail 50 || true
            exit 1
          fi

      - name: Verify host override DLL in container
        if: env.E2E_HOST_OVERRIDE_MOUNTED == 'true'
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Verifying host override DLL inside container"

          # Compute SHA256 of the DLL as seen inside the container
          CONTAINER_SHA256=$(docker exec "$CONTAINER_NAME" sha256sum /app/bin/Lidarr.Common.dll 2>/dev/null | cut -d' ' -f1 || echo "")

          if [ -z "$CONTAINER_SHA256" ]; then
            echo "::warning::Could not compute SHA256 inside container (sha256sum may not exist)"
            echo "::endgroup::"
            exit 0
          fi

          EXPECTED_SHA256="${HOST_OVERRIDE_DLL_SHA256:-}"

          if [ -z "$EXPECTED_SHA256" ]; then
            echo "::warning::No expected SHA256 available for comparison"
            echo "Container DLL SHA256: $CONTAINER_SHA256"
            echo "::endgroup::"
            exit 0
          fi

          if [ "$CONTAINER_SHA256" != "$EXPECTED_SHA256" ]; then
            echo "::error::Host override DLL verification FAILED!"
            echo "::error::Expected (host):    $EXPECTED_SHA256"
            echo "::error::Got (container):    $CONTAINER_SHA256"
            echo "::error::This may indicate a mount failure or path mismatch."
            echo "::endgroup::"
            exit 1
          fi

          echo "✓ Host override DLL verified inside container"
          echo "  SHA256: ${CONTAINER_SHA256:0:16}..."
          echo "::endgroup::"

      - name: Extract API key
        id: api-key
        shell: bash
        run: |
          set -euo pipefail

          # Extract API key from container config
          API_KEY=$(docker exec "$CONTAINER_NAME" cat /config/config.xml 2>/dev/null | grep -oP '(?<=<ApiKey>)[^<]+' || true)

          if [ -z "$API_KEY" ]; then
            echo "::error::Could not extract API key from container"
            exit 1
          fi

          # Mask the API key
          echo "::add-mask::$API_KEY"
          echo "LIDARR_API_KEY=$API_KEY" >> $GITHUB_ENV
          echo "API key extracted successfully"

      - name: Wait for plugins to load
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Waiting for plugin schemas..."

          # After API is ready, Lidarr still needs time to complete:
          # 1. Database migrations
          # 2. Plugin assembly loading
          # 3. DI registration
          # Poll indexer schema until plugin implementations appear

          n=0
          max_retries=60  # 120 seconds total (migrations can take 30+ seconds)
          while [ "$n" -lt "$max_retries" ]; do
            # Check if Qobuzarr schema exists (first plugin in list)
            # Use grep -o and wc -l to reliably count matches
            response=$(curl -s "http://localhost:8686/api/v1/indexer/schema" \
              -H "X-Api-Key: $LIDARR_API_KEY" 2>/dev/null || true)

            # Check if response contains "Qobuzarr" (indicating plugin loaded)
            if echo "$response" | grep -q "Qobuzarr"; then
              echo "✓ Plugin schemas loaded (found Qobuzarr in indexer schema)"
              break
            fi

            n=$((n+1))
            echo "Waiting for plugin schemas ($n/$max_retries)..."
            sleep 2
          done

          if [ "$n" -ge "$max_retries" ]; then
            echo "::warning::Plugin schemas did not appear after 120 seconds"

            # Check for E2E_HOST_PLUGIN_DISCOVERY_DISABLED condition:
            # - Plugin files exist in /config/plugins/
            # - /api/v1/system/plugins returns [] or doesn't include our plugins
            # - Schemas don't include plugin implementations
            echo ""
            echo "::group::Discovery-disabled detection"

            plugin_files_exist="false"
            if docker exec "$CONTAINER_NAME" find /config/plugins -name "plugin.json" -type f 2>/dev/null | grep -q .; then
              plugin_files_exist="true"
              echo "Plugin files found in container:"
              docker exec "$CONTAINER_NAME" find /config/plugins -name "plugin.json" -type f 2>/dev/null || true
            fi

            system_plugins=$(curl -s "http://localhost:8686/api/v1/system/plugins" -H "X-Api-Key: $LIDARR_API_KEY" 2>/dev/null || echo "[]")
            system_plugins_empty="false"
            if echo "$system_plugins" | grep -q '^\[\]$'; then
              system_plugins_empty="true"
            fi

            if [ "$plugin_files_exist" = "true" ] && [ "$system_plugins_empty" = "true" ]; then
              echo ""
              echo "::error::E2E_HOST_PLUGIN_DISCOVERY_DISABLED: Plugins exist on disk but host is not loading them"
              echo "E2E_HOST_PLUGIN_DISCOVERY_DISABLED=true" >> $GITHUB_ENV
              echo ""
              echo "REMEDIATION:"
              echo "  1. Enable host override (use_host_override=always) to mount patched Lidarr.Common.dll"
              echo "  2. Pin to a known-working Lidarr tag (e.g., pr-plugins-3.1.1.4884)"
              echo "  3. Check if this Lidarr version requires plugin manager API installation"
              echo ""
            fi

            echo "::endgroup::"

            echo "Indexer schema response (first 1000 chars):"
            curl -s "http://localhost:8686/api/v1/indexer/schema" \
              -H "X-Api-Key: $LIDARR_API_KEY" 2>/dev/null | head -c 1000 || true
            echo ""
            echo "Container status:"
            docker ps -a --filter "name=$CONTAINER_NAME" --format "{{.Status}}" || true
            echo "Recent container logs:"
            docker logs "$CONTAINER_NAME" --tail 30 2>&1 || true
          fi

          echo "::endgroup::"

      # =========================================================================
      # RUN E2E GATES
      # =========================================================================
      - name: Run E2E gates
        id: run-gates
        shell: pwsh
        env:
          # Qobuzarr credentials
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZARR_COUNTRY_CODE: ${{ secrets.QOBUZARR_COUNTRY_CODE }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          QOBUZ_COUNTRY_CODE: ${{ secrets.QOBUZ_COUNTRY_CODE }}
          # Tidalarr credentials
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_CONFIG_PATH: ${{ secrets.TIDALARR_CONFIG_PATH }}
          TIDALARR_TOKENS_JSON_B64: ${{ secrets.TIDALARR_TOKENS_JSON_B64 }}
          TIDALARR_MARKET: ${{ secrets.TIDALARR_MARKET }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          TIDAL_MARKET: ${{ secrets.TIDAL_MARKET }}
          # Brainarr LLM credentials
          BRAINARR_LLM_BASE_URL: ${{ secrets.BRAINARR_LLM_BASE_URL }}
          BRAINARR_MODEL_ID: ${{ secrets.BRAINARR_MODEL_ID }}
          BRAINARR_MODEL: ${{ secrets.BRAINARR_MODEL }}
          BRAINARR_PROVIDER: ${{ secrets.BRAINARR_PROVIDER }}
        run: |
          # Set gate configuration from inputs
          if ($env:INPUT_VALIDATE_METADATA -eq "true") {
            $env:E2E_VALIDATE_METADATA = "1"
          }
          if ($env:INPUT_FORCE_CONFIG_UPDATE -eq "true") {
            $env:E2E_FORCE_CONFIG_UPDATE = "1"
          }

          # Determine gate to run
          $gate = "configure"  # Always start with configure

          if ($env:INPUT_RUN_SEARCH_GATE -eq "true") {
            $gate = "all"  # 'all' includes search, albumsearch, grab
          }
          if ($env:INPUT_RUN_IMPORTLIST_GATE -eq "true" -and $gate -eq "configure") {
            $gate = "importlist"
          }
          if ($env:INPUT_RUN_GRAB_GATE -eq "true") {
            $gate = "all"
          }

          Write-Host "Running E2E gates: $gate" -ForegroundColor Cyan
          Write-Host "Plugins: $env:INPUT_PLUGINS" -ForegroundColor Gray

          $params = @{
            Plugins = $env:INPUT_PLUGINS
            Gate = $gate
            LidarrUrl = "http://localhost:8686"
            ApiKey = $env:LIDARR_API_KEY
            ContainerName = $env:CONTAINER_NAME
            DiagnosticsPath = "./.e2e-bootstrap/diagnostics"
            EmitJson = $true  # Always emit manifest for CI validation
          }

          # CI semantics: if we're running credentialed gates, missing creds should FAIL (not SKIP).
          # This prevents "silent green" where Search/Grab are skipped due to missing secrets.
          if ($gate -ne "configure") {
            $params.StrictPrereqs = $true
          }

          # Enable idempotent Configure for non-cold-start runs (reduces SKIP spam)
          if ($env:E2E_COLD_START -ne "true") {
            $params.ConfigurePassIfAlreadyConfigured = $true
          }

          if ($env:INPUT_VALIDATE_METADATA -eq "true") {
            $params.ValidateMetadata = $true
          }

          if ($env:INPUT_FORCE_CONFIG_UPDATE -eq "true") {
            $params.ForceConfigUpdate = $true
          }

          if ($env:INPUT_POST_RESTART_GRAB -eq "true") {
            $params.PostRestartGrab = $true
            $timeoutMin = [int]$env:INPUT_POST_RESTART_GRAB_TIMEOUT_MIN
            if ($timeoutMin -gt 0) {
              $params.PostRestartGrabTimeoutMin = $timeoutMin
            }
          }

          if ($env:INPUT_RUN_BRAINARR_LLM_GATE -eq "true" -or $env:BRAINARR_LLM_BASE_URL) {
            $params.RunBrainarrLLMGate = $true
            if ($env:BRAINARR_LLM_BASE_URL) {
              $params.BrainarrLLMBaseUrl = $env:BRAINARR_LLM_BASE_URL
            }
            if ($env:BRAINARR_MODEL_ID) {
              $params.BrainarrModelId = $env:BRAINARR_MODEL_ID
            }
            if ($env:INPUT_STRICT_BRAINARR -eq "true") {
              $params.StrictBrainarr = $true
            }
            $syncTimeout = [int]$env:INPUT_BRAINARR_SYNC_TIMEOUT_SEC
            if ($syncTimeout -gt 0) {
              $params.BrainarrSyncTimeoutSec = $syncTimeout
            }
          }

          # Run the e2e-runner
          try {
            & ./scripts/e2e-runner.ps1 @params
            $exitCode = $LASTEXITCODE
          } catch {
            Write-Host "::error::E2E runner threw exception: $_"
            $exitCode = 1
          }

          if ($exitCode -ne 0) {
            Write-Host "::error::E2E gates failed with exit code $exitCode"
            exit $exitCode
          }

          Write-Host "E2E gates completed successfully" -ForegroundColor Green

      - name: Validate run manifest schema
        if: always()
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $manifestPath = ".e2e-bootstrap/diagnostics/run-manifest.json"
          if (-not (Test-Path $manifestPath)) {
            Write-Host "::warning::Run manifest not found at $manifestPath; skipping schema validation." -ForegroundColor Yellow
            exit 0
          }

          # Use CI wrapper with -Strict to treat "no validator" as failure
          & ./scripts/ci/validate-manifest-ci.ps1 -ManifestPath $manifestPath -Strict -Quiet
          if ($LASTEXITCODE -ne 0) {
            Write-Host "::error::Run manifest schema validation failed"
            exit 1
          }

      # =========================================================================
      # COLD-START ASSERTIONS: Validate expected outcomes in manifest
      # =========================================================================
      - name: Validate cold-start assertions
        if: env.E2E_COLD_START == 'true'
        shell: pwsh
        env:
          # Check if secrets were provided
          HAS_QOBUZ_CREDS: ${{ secrets.QOBUZARR_AUTH_TOKEN != '' || secrets.QOBUZ_AUTH_TOKEN != '' }}
          HAS_TIDAL_CREDS: ${{ secrets.TIDALARR_REDIRECT_URL != '' || secrets.TIDAL_REDIRECT_URL != '' || secrets.TIDALARR_CONFIG_PATH != '' }}
          HAS_BRAINARR_CREDS: ${{ secrets.BRAINARR_LLM_BASE_URL != '' }}
        run: |
          & ./scripts/ci/assert-cold-start.ps1 `
            -ManifestPath ".e2e-bootstrap/diagnostics/run-manifest.json" `
            -Plugins "$env:INPUT_PLUGINS" `
            -HasQobuzCreds "$env:HAS_QOBUZ_CREDS" `
            -HasTidalCreds "$env:HAS_TIDAL_CREDS" `
            -HasBrainarrCreds "$env:HAS_BRAINARR_CREDS"
          exit $LASTEXITCODE

      # =========================================================================
      # WARM-RUN ASSERTION: Prefer stored component IDs
      # Proves the second Configure run uses preferred IDs after state persistence.
      # =========================================================================
      - name: Validate warm-run uses preferred IDs
        if: env.E2E_COLD_START == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $statePath = ".e2e-bootstrap/e2e-component-ids.json"
          if (-not (Test-Path $statePath)) {
            Write-Host "No component ID state file found; skipping warm-run assertion." -ForegroundColor Yellow
            exit 0
          }

          Import-Module "./scripts/lib/e2e-component-ids.psm1" -Force
          $salt = $env:E2E_COMPONENT_IDS_INSTANCE_SALT
          $instanceKey = Get-E2EComponentIdsInstanceKey -LidarrUrl "http://localhost:8686" -ContainerName $env:CONTAINER_NAME -InstanceSalt ($salt ?? "")
          $state = Read-E2EComponentIdsState -Path $statePath

          $pluginsState = $null
          if ($state.instances.ContainsKey($instanceKey)) {
            $pluginsState = $state.instances[$instanceKey].plugins
          } elseif ($state.instances.ContainsKey("legacy") -and $state.instances.Count -eq 1) {
            $pluginsState = $state.instances["legacy"].plugins
          }

          if ($null -eq $pluginsState -or $pluginsState.Count -eq 0) {
            Write-Host "No stored component IDs for instanceKey '$instanceKey'; skipping warm-run assertion." -ForegroundColor Yellow
            exit 0
          }

          $warmManifestPath = ".e2e-bootstrap/diagnostics/warm-run-manifest.json"
          $params = @{
            Plugins = $env:INPUT_PLUGINS
            Gate = "configure"
            LidarrUrl = "http://localhost:8686"
            ApiKey = $env:LIDARR_API_KEY
            ContainerName = $env:CONTAINER_NAME
            DiagnosticsPath = "./.e2e-bootstrap/diagnostics"
            EmitJson = $true
            JsonOutputPath = $warmManifestPath
            ConfigurePassIfAlreadyConfigured = $true
            ComponentIdsInstanceSalt = ($env:E2E_COMPONENT_IDS_INSTANCE_SALT ?? "")
          }

          & ./scripts/e2e-runner.ps1 @params
          if ($LASTEXITCODE -ne 0) {
            Write-Host "::error::Warm Configure run failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          }

          if (-not (Test-Path $warmManifestPath)) {
            Write-Host "::error::Warm-run manifest not found at '$warmManifestPath'"
            exit 1
          }

          $warmManifest = Get-Content $warmManifestPath -Raw | ConvertFrom-Json
          $failures = @()

          foreach ($pluginName in $pluginsState.Keys) {
            $configure = @($warmManifest.results | Where-Object { $_.gate -eq "Configure" -and $_.plugin -eq $pluginName }) | Select-Object -First 1
            if (-not $configure) {
              $failures += "[$pluginName] Warm run missing Configure result"
              continue
            }
            if ($configure.outcome -ne "success") {
              $failures += "[$pluginName] Warm Configure expected success, got $($configure.outcome)"
              continue
            }
            if (-not $configure.details -or $configure.details.preferredIdUsed -ne $true) {
              $failures += "[$pluginName] Warm Configure expected details.preferredIdUsed=true"
              continue
            }
          }

          if ($failures.Count -gt 0) {
            Write-Host "::error::Warm-run preferred ID assertion failed with $($failures.Count) issue(s):"
            foreach ($f in $failures) {
              Write-Host "  - $f" -ForegroundColor Red
            }
            exit 1
          }

          Write-Host "Warm-run preferred ID assertion passed" -ForegroundColor Green

      # =========================================================================
      # NO-JUNK API CHECK: Verify no stray components created (cold-start only)
      # =========================================================================
      - name: Verify no junk components created
        if: env.E2E_COLD_START == 'true'
        shell: bash
        env:
          HAS_QOBUZ_CREDS: ${{ secrets.QOBUZARR_AUTH_TOKEN != '' || secrets.QOBUZ_AUTH_TOKEN != '' }}
          HAS_TIDAL_CREDS: ${{ secrets.TIDALARR_REDIRECT_URL != '' || secrets.TIDAL_REDIRECT_URL != '' || secrets.TIDALARR_CONFIG_PATH != '' }}
          HAS_BRAINARR_CREDS: ${{ secrets.BRAINARR_LLM_BASE_URL != '' }}
        run: |
          set -euo pipefail

          # Only run this check if NO secrets were provided (Case A)
          if [[ "$HAS_QOBUZ_CREDS" == "true" || "$HAS_TIDAL_CREDS" == "true" || "$HAS_BRAINARR_CREDS" == "true" ]]; then
            echo "Skipping no-junk check - secrets were provided (Case B)"
            exit 0
          fi

          echo "Verifying no junk components were created (Case A - no secrets)..."

          fetch_json() {
            local url="$1"
            local attempts=10
            local delay=2

            for ((i=1; i<=attempts; i++)); do
              if out=$(curl -fsS "$url" -H "X-Api-Key: $LIDARR_API_KEY"); then
                echo "$out"
                return 0
              fi
              echo "Retry $i/$attempts: $url not ready yet"
              sleep "$delay"
            done

            echo "::error::Failed to query $url after $attempts attempts"
            return 1
          }

          # IMPORTANT: Do not assert total counts are 0. Lidarr may create defaults.
          # We assert that no plugin-specific components were created.
          # (Components are considered plugin-specific if implementationName matches plugin name.)

          indexers_json="$(fetch_json 'http://localhost:8686/api/v1/indexer')"
          clients_json="$(fetch_json 'http://localhost:8686/api/v1/downloadclient')"
          importlists_json="$(fetch_json 'http://localhost:8686/api/v1/importlist')"

          plugin_indexer_count=$(echo "$indexers_json" | jq '[.[] | select(
              (.implementationName == "Qobuzarr") or
              (.implementation == "QobuzIndexer") or
              (.implementationName == "Tidalarr") or
              (.implementation == "TidalLidarrIndexer")
            )] | length')
          plugin_client_count=$(echo "$clients_json" | jq '[.[] | select(
              (.implementationName == "Qobuzarr") or
              (.implementation == "QobuzDownloadClient") or
              (.implementationName == "Tidalarr") or
              (.implementation == "TidalLidarrDownloadClient")
            )] | length')
          plugin_importlist_count=$(echo "$importlists_json" | jq '[.[] | select(
              (.implementationName == "Brainarr") or
              (.implementation == "BrainarrImportList")
            )] | length')

          if [[ "$plugin_indexer_count" -gt 0 ]]; then
            echo "::error::Found $plugin_indexer_count plugin indexer(s) in cold-start without secrets (expected 0)"
            echo "$indexers_json" | jq -c '[.[] | select(
                (.implementationName == "Qobuzarr") or
                (.implementation == "QobuzIndexer") or
                (.implementationName == "Tidalarr") or
                (.implementation == "TidalLidarrIndexer")
              ) | {id, name, implementationName, implementation}]'
            exit 1
          fi

          if [[ "$plugin_client_count" -gt 0 ]]; then
            echo "::error::Found $plugin_client_count plugin download client(s) in cold-start without secrets (expected 0)"
            echo "$clients_json" | jq -c '[.[] | select(
                (.implementationName == "Qobuzarr") or
                (.implementation == "QobuzDownloadClient") or
                (.implementationName == "Tidalarr") or
                (.implementation == "TidalLidarrDownloadClient")
              ) | {id, name, implementationName, implementation}]'
            exit 1
          fi

          if [[ "$plugin_importlist_count" -gt 0 ]]; then
            echo "::error::Found $plugin_importlist_count Brainarr import list(s) in cold-start without secrets (expected 0)"
            echo "$importlists_json" | jq -c '[.[] | select(
                (.implementationName == "Brainarr") or
                (.implementation == "BrainarrImportList")
              ) | {id, name, implementationName, implementation}]'
            exit 1
          fi

          echo "No-junk check passed: no plugin-specific indexers/download clients/import lists were created"

      # =========================================================================
      # JOB SUMMARY: Parse v1.2 manifest for first-pass triage (best-effort)
      # =========================================================================
      - name: Generate job summary
        if: always()
        continue-on-error: true
        shell: pwsh
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          E2E_COLD_START: ${{ env.E2E_COLD_START }}
        run: |
          # Best-effort summary generation - never fail the build
          $ErrorActionPreference = 'Continue'
          $manifestPath = ".e2e-bootstrap/diagnostics/run-manifest.json"
          $summaryFile = $env:GITHUB_STEP_SUMMARY
          $artifactUrl = "$($env:GITHUB_SERVER_URL)/$($env:GITHUB_REPOSITORY)/actions/runs/$($env:GITHUB_RUN_ID)"

          function Write-FallbackSummary {
            param([string]$Title, [string]$Message)
            $sb = [System.Text.StringBuilder]::new()
            [void]$sb.AppendLine("## :warning: $Title")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine($Message)
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("### Next Steps")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("1. Check the [workflow logs]($artifactUrl) for error details")
            [void]$sb.AppendLine("2. Download the ``e2e-diagnostics`` artifact for full context")
            [void]$sb.AppendLine("3. Look for ``run-manifest.json`` in the diagnostics bundle")
            $sb.ToString() | Out-File -FilePath $summaryFile -Encoding utf8
          }

          # Check if manifest exists
          if (-not (Test-Path $manifestPath)) {
            Write-FallbackSummary -Title "E2E Run Manifest Not Found" -Message "The run manifest was not generated. This usually means the runner failed before completing or crashed during execution."
            Write-Host "::warning::Run manifest not found at $manifestPath"
            exit 0
          }

          # Check if manifest is empty or too small
          $fileInfo = Get-Item $manifestPath
          if ($fileInfo.Length -lt 50) {
            Write-FallbackSummary -Title "E2E Run Manifest Empty/Corrupt" -Message "The run manifest exists but appears to be empty or corrupt (size: $($fileInfo.Length) bytes)."
            Write-Host "::warning::Run manifest too small: $($fileInfo.Length) bytes"
            exit 0
          }

          try {
            $rawJson = Get-Content $manifestPath -Raw
            $manifest = $rawJson | ConvertFrom-Json

            # Validate required fields exist (backward compat check)
            if (-not $manifest.schemaVersion) {
              Write-FallbackSummary -Title "E2E Run Manifest Invalid" -Message "The run manifest is missing required field ``schemaVersion``. This may be a v1.0 manifest or corrupt file."
              exit 0
            }

            $sb = [System.Text.StringBuilder]::new()

            # Header with overall status
            $statusEmoji = if ($manifest.summary.overallSuccess) { ":white_check_mark:" } else { ":x:" }
            $statusText = if ($manifest.summary.overallSuccess) { "PASSED" } else { "FAILED" }

            [void]$sb.AppendLine("## $statusEmoji E2E Bootstrap: $statusText")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("| Metric | Value |")
            [void]$sb.AppendLine("|--------|-------|")
            [void]$sb.AppendLine("| Schema Version | ``$($manifest.schemaVersion)`` |")
            [void]$sb.AppendLine("| Lidarr | ``$($manifest.lidarr.version ?? 'n/a')`` @ ``$($manifest.lidarr.branch ?? 'n/a')`` |")
            [void]$sb.AppendLine("| Image | ``$($manifest.lidarr.imageTag ?? 'n/a')`` |")
            $durationSec = if ($manifest.summary.totalDurationMs) { [math]::Round($manifest.summary.totalDurationMs / 1000, 1) } else { 0 }
            [void]$sb.AppendLine("| Duration | ${durationSec}s |")
            if ($env:E2E_COLD_START -eq 'true') {
              [void]$sb.AppendLine("| Mode | :snowflake: **Cold Start** (fresh config) |")
            }
            # Show host override status from manifest
            if ($manifest.lidarr.hostOverride -and $manifest.lidarr.hostOverride.used) {
              $overrideSha = if ($manifest.lidarr.hostOverride.sha) { $manifest.lidarr.hostOverride.sha.Substring(0, 7) } else { 'unknown' }
              $dllHash = if ($manifest.lidarr.hostOverride.dllSha256) { $manifest.lidarr.hostOverride.dllSha256.Substring(0, 12) + '...' } else { $null }
              $overrideInfo = "SHA: ``$overrideSha``"
              if ($dllHash) { $overrideInfo += ", DLL: ``$dllHash``" }
              [void]$sb.AppendLine("| Host Override | :wrench: **Enabled** ($overrideInfo) |")
            }
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("### Gate Results")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("| Gate | Plugin | Outcome | Duration |")
            [void]$sb.AppendLine("|------|--------|---------|----------|")

            if ($manifest.results) {
              foreach ($result in $manifest.results) {
                $outcomeEmoji = switch ($result.outcome) {
                  "success" { ":white_check_mark:" }
                  "failed" { ":x:" }
                  "skipped" { ":fast_forward:" }
                  default { ":question:" }
                }
                $duration = if ($result.durationMs) { "$([math]::Round($result.durationMs / 1000, 1))s" } else { "n/a" }
                [void]$sb.AppendLine("| $($result.gate ?? 'unknown') | $($result.plugin ?? 'unknown') | $outcomeEmoji $($result.outcome ?? 'unknown') | $duration |")
              }

              # Failed gates detail section with action hints
              $failedGates = @($manifest.results | Where-Object { $_.outcome -eq "failed" })
              if ($failedGates.Count -gt 0) {
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("### :x: Failed Gates")

                # Action hint lookup based on error codes
                $actionHints = @{
                  'E2E_AUTH_MISSING'         = ':key: **Action:** Set the required secrets in repository settings'
                  'E2E_API_TIMEOUT'          = ':hourglass: **Action:** Check network connectivity or increase timeout'
                  'E2E_NO_RELEASES_ATTRIBUTED' = ':cd: **Action:** Verify indexer credentials and search query'
                  'E2E_QUEUE_NOT_FOUND'      = ':inbox_tray: **Action:** Check download client configuration'
                  'E2E_ZERO_AUDIO_FILES'     = ':musical_note: **Action:** Verify download completed with audio files'
                  'E2E_METADATA_MISSING'     = ':label: **Action:** Check plugin metadata extraction logic'
                  'E2E_DOCKER_UNAVAILABLE'   = ':whale: **Action:** Ensure Docker daemon is running'
                  'E2E_CONFIG_INVALID'       = ':gear: **Action:** Review plugin configuration settings'
                  'E2E_IMPORT_FAILED'        = ':package: **Action:** Check import paths and permissions'
                  'E2E_HOST_PLUGIN_DISCOVERY_DISABLED' = ':no_entry: **Action:** Enable host override (use_host_override=always) or pin to known-working Lidarr tag'
                }

                foreach ($failed in $failedGates) {
                  [void]$sb.AppendLine("")
                  [void]$sb.AppendLine("**$($failed.gate) ($($failed.plugin))**")
                  if ($failed.errorCode) {
                    [void]$sb.AppendLine("- Error Code: ``$($failed.errorCode)``")
                    # Add action hint if available
                    if ($actionHints.ContainsKey($failed.errorCode)) {
                      [void]$sb.AppendLine("- $($actionHints[$failed.errorCode])")
                    }
                  }
                  if ($failed.outcomeReason) {
                    [void]$sb.AppendLine("- Reason: $($failed.outcomeReason)")
                  }
                  if ($failed.errors -and $failed.errors.Count -gt 0) {
                    [void]$sb.AppendLine("- Errors:")
                    foreach ($err in $failed.errors | Select-Object -First 3) {
                      [void]$sb.AppendLine("  - ``$err``")
                    }
                  }
                }

                # Host bug detection action hints
                if ($manifest.hostBugSuspected -and $manifest.hostBugSuspected.detected) {
                  $hostHint = switch ($manifest.hostBugSuspected.classification) {
                    'ALC'              { ':rotating_light: **Action:** Report to Lidarr maintainers - this is a host runtime bug' }
                    'ABI_MISMATCH'     { ':hammer: **Action:** Rebuild plugins against the current host version' }
                    'DEPENDENCY_DRIFT' { ':link: **Action:** Check assembly binding redirects or update dependencies' }
                    'LOAD_FAILURE'     { ':mag: **Action:** Investigate assembly loading - check paths and permissions' }
                    'TYPE_INIT_FAILURE' { ':warning: **Action:** Check static constructors and configuration loading' }
                    default            { ':grey_question: **Action:** Investigate assembly loading issues' }
                  }
                  [void]$sb.AppendLine("")
                  [void]$sb.AppendLine("### :rotating_light: Host Issue Detected")
                  [void]$sb.AppendLine("- Classification: ``$($manifest.hostBugSuspected.classification)``")
                  [void]$sb.AppendLine("- Severity: ``$($manifest.hostBugSuspected.severity)``")
                  [void]$sb.AppendLine("- $hostHint")
                }
              }

              # Discovery-disabled warning (env var set by Wait for plugins to load step)
              if ($env:E2E_HOST_PLUGIN_DISCOVERY_DISABLED -eq 'true') {
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("### :no_entry: Plugin Discovery Disabled")
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("**Plugins exist on disk but Lidarr is not loading them.**")
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("This Lidarr version may have disabled file-based plugin discovery.")
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("**Remediation:**")
                [void]$sb.AppendLine("1. Enable host override: ``use_host_override=always``")
                [void]$sb.AppendLine("2. Pin to known-working tag: ``pr-plugins-3.1.1.4884``")
                [void]$sb.AppendLine("3. Check if plugins need API-based installation")
              }

              # Skipped gates section
              $skippedGates = @($manifest.results | Where-Object { $_.outcome -eq "skipped" })
              if ($skippedGates.Count -gt 0) {
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("### :fast_forward: Skipped Gates")
                foreach ($skipped in $skippedGates) {
                  $reason = if ($skipped.outcomeReason) { $skipped.outcomeReason } else { "No reason provided" }
                  [void]$sb.AppendLine("- **$($skipped.gate) ($($skipped.plugin))**: $reason")
                }
              }
            }

            # Stop reason if present (v1.2+)
            if ($manifest.effective -and $manifest.effective.stopReason) {
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("### :stop_sign: Pipeline Stopped")
              [void]$sb.AppendLine("Reason: $($manifest.effective.stopReason)")
            }

            # Sources section (collapsed, v1.2+)
            if ($manifest.sources) {
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("<details>")
              [void]$sb.AppendLine("<summary>Source Versions</summary>")
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("| Repo | SHA | Source |")
              [void]$sb.AppendLine("|------|-----|--------|")
              foreach ($repo in @('common', 'qobuzarr', 'tidalarr', 'brainarr')) {
                $src = $manifest.sources.$repo
                $sha = if ($src -and $src.sha) { $src.sha } else { "n/a" }
                $prov = if ($src -and $src.source) { $src.source } else { "unknown" }
                [void]$sb.AppendLine("| $repo | ``$sha`` | $prov |")
              }
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("</details>")
            }

            # Artifact link
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("---")
            [void]$sb.AppendLine(":package: [View full artifacts]($artifactUrl)")

            $sb.ToString() | Out-File -FilePath $summaryFile -Encoding utf8
            Write-Host "Job summary generated successfully"

          } catch {
            Write-Host "::warning::Failed to parse run manifest: $_"
            Write-FallbackSummary -Title "Error Parsing Run Manifest" -Message "Failed to parse the run manifest JSON: ``$_``"
          }

      # =========================================================================
      # ALWAYS COLLECT DIAGNOSTICS (on success or failure)
      # =========================================================================
      - name: Collect container diagnostics
        if: always()
        shell: bash
        run: |
          set +e
          mkdir -p .e2e-bootstrap/diagnostics

          echo "::group::Container status"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" | tee .e2e-bootstrap/diagnostics/containers.txt
          echo "::endgroup::"

          if docker ps -a --format '{{.Names}}' | grep -qF "$CONTAINER_NAME"; then
            echo "::group::Container logs"
            docker logs "$CONTAINER_NAME" --tail 5000 2>&1 | tee .e2e-bootstrap/diagnostics/container.log
            echo "::endgroup::"

            echo "::group::Container inspect"
            docker inspect "$CONTAINER_NAME" > .e2e-bootstrap/diagnostics/inspect.json 2>&1
            echo "::endgroup::"

            echo "::group::Plugin folder listing"
            docker exec "$CONTAINER_NAME" find /config/plugins -maxdepth 4 -type f -printf '%p\n' 2>/dev/null | tee .e2e-bootstrap/diagnostics/plugin-files.txt || echo "Could not list plugin files"
            echo "::endgroup::"

            # Clean up cold-start config from INSIDE container (files are root-owned)
            # This must happen before container removal to avoid permission errors on host
            if [[ "${E2E_COLD_START:-false}" == "true" ]]; then
              echo "::group::Cleanup cold-start config (in-container)"
              docker exec "$CONTAINER_NAME" sh -c "rm -rf /config/* 2>/dev/null" || true
              echo "::endgroup::"
            fi

            # Stop and remove container
            docker rm -f "$CONTAINER_NAME" || true
          fi

      - name: Upload run manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run-manifest
          path: run-manifest.json
          if-no-files-found: warn

      - name: Upload diagnostics bundle
        if: failure() || inputs.upload_diagnostics_on_success
        uses: actions/upload-artifact@v4
        with:
          name: e2e-diagnostics-${{ github.run_id }}
          path: |
            .e2e-bootstrap/diagnostics/
            .e2e-bootstrap/config*/logs/
          if-no-files-found: warn
          retention-days: 14

      - name: Upload plugin zips (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: plugin-packages
          path: |
            qobuzarr/**/*.zip
            tidalarr/**/*.zip
            brainarr/**/*.zip
          if-no-files-found: warn

      # =========================================================================
      # FINAL CLEANUP: Remove cold-start config dir (diagnostics already captured)
      # Safety: Validates path contains expected prefix before deletion
      # =========================================================================
      - name: Cleanup cold-start config
        if: always() && env.E2E_COLD_START == 'true'
        shell: bash
        run: |
          # Remove this run's cold-start config directory (logs already in diagnostics artifact)
          # NOTE: Container cleanup happens in "Collect container diagnostics" step via docker exec
          # This step handles any remaining host-side cleanup
          # SAFETY: Only delete if path is anchored to .e2e-bootstrap/ AND contains config-cold-
          CONFIG_DIR="${E2E_CONFIG_DIR:-}"
          if [ -n "$CONFIG_DIR" ] && [ -d "$CONFIG_DIR" ]; then
            # Validate path structure before deletion
            if [[ "$CONFIG_DIR" == .e2e-bootstrap/config-cold-* ]]; then
              echo "Cleaning up cold-start config: $CONFIG_DIR"
              # Files should already be removed by docker exec; this cleans empty dirs
              rm -rf "$CONFIG_DIR" 2>/dev/null || {
                echo "::warning::Could not fully remove $CONFIG_DIR (likely root-owned files remain)"
                ls -la "$CONFIG_DIR" 2>/dev/null || true
              }
            else
              echo "::warning::Skipping cleanup - path does not match expected pattern: $CONFIG_DIR"
            fi
          fi

  # ===========================================================================
  # CANARY JOB: Test against latest pr-plugins tag (non-blocking)
  # Catches host regressions early by testing the moving tag
  # ===========================================================================
  canary:
    name: Canary (pr-plugins latest)
    if: inputs.run_canary == true
    runs-on: ubuntu-latest
    continue-on-error: true  # Never block main workflow - this is informational
    env:
      CANARY_TAG: pr-plugins  # Moving tag - always latest plugins branch build
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install PowerShell
        shell: bash
        run: |
          set -euo pipefail
          if command -v pwsh >/dev/null 2>&1; then
            echo "PowerShell already installed"
            exit 0
          fi
          . /etc/os-release || true
          CODENAME=${VERSION_CODENAME:-"jammy"}
          curl -fsSL "https://packages.microsoft.com/config/ubuntu/$CODENAME/packages-microsoft-prod.deb" -o packages-microsoft-prod.deb \
            || curl -fsSL "https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb" -o packages-microsoft-prod.deb
          sudo dpkg -i packages-microsoft-prod.deb
          sudo apt-get update
          sudo apt-get install -y powershell

      - name: Redaction self-test
        shell: pwsh
        run: |
          Import-Module "$env:GITHUB_WORKSPACE/scripts/lib/e2e-diagnostics.psm1" -Force
          $result = Test-SecretRedaction
          if (-not $result) { throw "Redaction self-test failed" }

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Checkout Qobuzarr
        if: contains(inputs.plugins, 'Qobuzarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Qobuzarr
          ref: main
          path: qobuzarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Tidalarr
        if: contains(inputs.plugins, 'Tidalarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Tidalarr
          ref: main
          path: tidalarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Brainarr
        if: contains(inputs.plugins, 'Brainarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Brainarr
          ref: main
          path: brainarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Pull canary Lidarr image
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/hotio/lidarr:${CANARY_TAG}"
          echo "::notice::CANARY: Testing against $IMAGE (moving tag)"

          n=0
          until [ "$n" -ge 3 ]; do
            docker pull "$IMAGE" && break
            n=$((n+1))
            echo "Pull failed ($n/3). Retrying in 10s..." && sleep 10
          done

          # Extract actual image digest for reporting
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || echo "unknown")
          echo "CANARY_DIGEST=$DIGEST" >> $GITHUB_ENV
          echo "::notice::Canary image digest: $DIGEST"

      - name: Extract Lidarr assemblies
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/hotio/lidarr:${CANARY_TAG}"
          cid=$(docker create "$IMAGE")
          mkdir -p _lidarr_extracted
          docker cp "$cid:/app" _lidarr_extracted/ 2>/dev/null || docker cp "$cid:/opt/lidarr" _lidarr_extracted/ 2>/dev/null || {
            docker rm "$cid" >/dev/null
            exit 1
          }
          docker rm "$cid" >/dev/null

          for plugin_dir in qobuzarr tidalarr brainarr; do
            if [ -d "$plugin_dir" ]; then
              mkdir -p "$plugin_dir/ext/Lidarr/_output/net8.0"
              find _lidarr_extracted -type f -name "*.dll" -exec cp {} "$plugin_dir/ext/Lidarr/_output/net8.0/" \;
            fi
          done
          rm -rf _lidarr_extracted

      - name: Sync tools to plugin submodules
        shell: bash
        run: |
          for plugin_dir in qobuzarr tidalarr brainarr; do
            submod="$plugin_dir/ext/Lidarr.Plugin.Common"
            if [ -d "$submod" ]; then
              [ -d "tools" ] && rm -rf "$submod/tools" && cp -r tools "$submod/tools"
              [ -d "build" ] && rm -rf "$submod/build" && cp -r build "$submod/build"
              [ -d "scripts" ] && rm -rf "$submod/scripts" && cp -r scripts "$submod/scripts"
            fi
          done

      - name: Build plugin packages
        shell: pwsh
        run: |
          $plugins = $env:INPUT_PLUGINS -split ','
          foreach ($plugin in $plugins) {
            $pluginLower = $plugin.Trim().ToLower()
            $pluginDir = "./$pluginLower"
            if (-not (Test-Path $pluginDir)) { continue }

            Push-Location $pluginDir
            try {
              if (Test-Path "build.ps1") {
                ./build.ps1 -Configuration Release -Restore -Package
              } else {
                Import-Module "../tools/PluginPack.psm1" -Force
                $csproj = Get-ChildItem -Filter "*.csproj" | Where-Object { $_.Name -notmatch "Tests" } | Select-Object -First 1
                if ($csproj) {
                  New-PluginPackage -Csproj $csproj.Name -Manifest "plugin.json" -MergeAssemblies -Framework "net8.0" -Configuration Release
                }
              }
            } finally {
              Pop-Location
            }
          }

      - name: Locate plugin zips
        id: locate-plugins
        shell: pwsh
        run: |
          $plugins = $env:INPUT_PLUGINS -split ','
          $pluginZips = @()
          foreach ($plugin in $plugins) {
            $pluginName = $plugin.Trim()
            $pluginDir = "./$($pluginName.ToLower())"
            if (Test-Path $pluginDir) {
              $zip = Get-ChildItem -Path $pluginDir -Recurse -Filter "*.zip" -ErrorAction SilentlyContinue |
                Where-Object { $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' -and $_.Name -match $pluginName } |
                Sort-Object LastWriteTimeUtc -Descending | Select-Object -First 1
              if ($zip) { $pluginZips += "$pluginName=$($zip.FullName)" }
            }
          }
          "PLUGIN_ZIPS=$($pluginZips -join ',')" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Start canary container
        id: start-container
        shell: bash
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          CONTAINER_NAME="lidarr-canary-${GITHUB_RUN_ID}"
          echo "CONTAINER_NAME=$CONTAINER_NAME" >> $GITHUB_ENV

          # Pre-seed: extract plugins before container starts
          mkdir -p .e2e-canary/config/plugins/RicherTunes .e2e-canary/downloads

          echo "::group::Pre-seed plugins for canary"
          IFS=',' read -ra ZIPS <<< "$PLUGIN_ZIPS"
          for entry in "${ZIPS[@]}"; do
            plugin_name="${entry%%=*}"
            zip_path="${entry#*=}"
            if [ -f "$zip_path" ]; then
              # Each plugin in its own subdirectory under the vendor folder
              plugin_dir=".e2e-canary/config/plugins/RicherTunes/$plugin_name"
              mkdir -p "$plugin_dir"
              echo "Extracting $plugin_name to $plugin_dir..."
              unzip -o "$zip_path" -d "$plugin_dir"
              echo "  ✓ $plugin_name extracted"
            else
              echo "::warning::Plugin zip not found: $zip_path"
            fi
          done
          echo "::endgroup::"

          # Verify plugins exist (hard check)
          plugin_count=$(find ".e2e-canary/config/plugins/RicherTunes" -name "plugin.json" -type f 2>/dev/null | wc -l)
          echo "Found $plugin_count plugin(s) for canary:"
          find ".e2e-canary/config/plugins/RicherTunes" -name "plugin.json" -type f || true

          docker run -d \
            --name "$CONTAINER_NAME" \
            -p 8687:8686 \
            -v "$(pwd)/.e2e-canary/config:/config" \
            -v "$(pwd)/.e2e-canary/downloads:/downloads" \
            -e PUID=1000 \
            -e PGID=1000 \
            "ghcr.io/hotio/lidarr:${CANARY_TAG}"

          echo "Waiting for canary Lidarr (plugins pre-seeded)..."

          n=0
          until [ "$n" -ge 45 ]; do
            curl -s "http://localhost:8687/api/v1/system/status" >/dev/null 2>&1 && break
            n=$((n+1))
            sleep 2
          done

      - name: Extract API key
        shell: bash
        run: |
          API_KEY=$(docker exec "$CONTAINER_NAME" cat /config/config.xml 2>/dev/null | grep -oP '(?<=<ApiKey>)[^<]+' || true)
          [ -z "$API_KEY" ] && exit 1
          echo "::add-mask::$API_KEY"
          echo "LIDARR_API_KEY=$API_KEY" >> $GITHUB_ENV

      - name: Wait for plugins to load (canary)
        shell: bash
        run: |
          echo "::group::Waiting for canary plugin schemas..."
          n=0
          max_retries=60
          while [ "$n" -lt "$max_retries" ]; do
            response=$(curl -s "http://localhost:8687/api/v1/indexer/schema" \
              -H "X-Api-Key: $LIDARR_API_KEY" 2>/dev/null || true)
            if echo "$response" | grep -q "Qobuzarr"; then
              echo "✓ Plugin schemas loaded (found Qobuzarr in indexer schema)"
              break
            fi
            n=$((n+1))
            echo "Waiting for plugin schemas ($n/$max_retries)..."
            sleep 2
          done
          if [ "$n" -ge "$max_retries" ]; then
            echo "::warning::Plugin schemas did not appear after 120 seconds"
            echo "Recent container logs:"
            docker logs "$CONTAINER_NAME" --tail 30 2>&1 || true
          fi
          echo "::endgroup::"

      - name: Run canary E2E gates
        id: run-gates
        shell: pwsh
        env:
          # Credentials for search-level canary (only used if canary_level=search)
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_CONFIG_PATH: ${{ secrets.TIDALARR_CONFIG_PATH }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
        run: |
          # Determine gate based on canary_level input
          $canaryLevel = $env:INPUT_CANARY_LEVEL
          if ([string]::IsNullOrEmpty($canaryLevel)) { $canaryLevel = "configure" }

          $gate = switch ($canaryLevel) {
            "search" { "albumsearch" }  # Includes Schema, Configure, Search, AlbumSearch
            default  { "configure" }     # Minimal: Schema + Configure only
          }

          Write-Host "::notice::CANARY: Running $gate gate (level=$canaryLevel) against pr-plugins (latest)" -ForegroundColor Cyan

          $params = @{
            Plugins = $env:INPUT_PLUGINS
            Gate = $gate
            LidarrUrl = "http://localhost:8687"
            ApiKey = $env:LIDARR_API_KEY
            ContainerName = $env:CONTAINER_NAME
            DiagnosticsPath = "./.e2e-canary/diagnostics"
          }
          
          # Canary semantics: if the canary is running credentialed gates, missing creds should FAIL (not SKIP).
          # This is non-blocking for the workflow overall (continue-on-error), but prevents “green-by-skip” canary runs.
          if ($gate -ne "configure") {
            $params.StrictPrereqs = $true
          }

          try {
            & ./scripts/e2e-runner.ps1 @params
            $exitCode = $LASTEXITCODE
          } catch {
            Write-Host "::warning::Canary gate threw exception: $_"
            $exitCode = 1
          }

          if ($exitCode -ne 0) {
            Write-Host "::warning::CANARY FAILED - Latest pr-plugins may have breaking changes"
            Write-Host "::warning::This is non-blocking but should be investigated"
            Write-Host "::notice::NOTE: Canary runs WITHOUT host override. Failure may indicate ALC bug still present in upstream."
          } else {
            Write-Host "::notice::CANARY PASSED - Plugins compatible with latest pr-plugins"
            Write-Host "::notice::OVERRIDE SIGNAL: Multi-plugin loading works WITHOUT patched DLL. Consider disabling host override."
          }

          exit $exitCode

      - name: Generate canary summary
        if: always()
        continue-on-error: true
        shell: pwsh
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          $manifestPath = ".e2e-canary/diagnostics/run-manifest.json"
          $canaryLevel = if ($env:INPUT_CANARY_LEVEL) { $env:INPUT_CANARY_LEVEL } else { "configure" }
          $sb = [System.Text.StringBuilder]::new()

          [void]$sb.AppendLine("## :bird: Canary Results (pr-plugins latest, level=$canaryLevel)")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("| Property | Value |")
          [void]$sb.AppendLine("|----------|-------|")
          [void]$sb.AppendLine("| Image Tag | ``pr-plugins`` (moving) |")
          [void]$sb.AppendLine("| Digest | ``$($env:CANARY_DIGEST ?? 'unknown')`` |")

          if (Test-Path $manifestPath) {
            try {
              $m = Get-Content $manifestPath -Raw | ConvertFrom-Json
              $status = if ($m.summary.overallSuccess) { ":white_check_mark: PASSED" } else { ":warning: FAILED" }
              [void]$sb.AppendLine("| Result | $status |")
              [void]$sb.AppendLine("| Lidarr Version | ``$($m.lidarr.version ?? 'n/a')`` |")
              [void]$sb.AppendLine("| Host Override | ``disabled`` (canary always runs without override) |")

              if ($m.summary.overallSuccess) {
                # === CANARY PASSED: Override may no longer be needed ===
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("### :mag: Override Necessity Signal")
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine(":white_check_mark: **Multi-plugin loading works WITHOUT patched DLL.**")
                [void]$sb.AppendLine("")
                [void]$sb.AppendLine("This suggests the upstream ALC bug may be fixed. Consider testing main workflow with ``use_host_override=never``.")
              } else {
                # === CANARY FAILED: Classify the failure ===
                [void]$sb.AppendLine("")

                # Known failure classifications (expected = ALC bug still present)
                $knownALCClassifications = @("ALC", "ALC_MISMATCH", "ASSEMBLY_LOAD_CONTEXT")
                $knownDiscoveryClassifications = @("DISCOVERY_DISABLED", "PLUGIN_NOT_LOADED")
                $knownABIClassifications = @("ABI_MISMATCH", "VERSION_CONFLICT", "DEPENDENCY_DRIFT")

                $classification = $m.hostBugSuspected.classification
                $isKnownALC = $knownALCClassifications -contains $classification
                $isKnownDiscovery = $knownDiscoveryClassifications -contains $classification
                $isKnownABI = $knownABIClassifications -contains $classification
                $isKnown = $isKnownALC -or $isKnownDiscovery -or $isKnownABI

                if ($m.hostBugSuspected -and $m.hostBugSuspected.detected) {
                  if ($isKnownALC) {
                    # Expected failure: ALC bug still present
                    [void]$sb.AppendLine("### :rotating_light: Expected Failure: ALC Bug Still Present")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine("| Classification | ``$classification`` |")
                    [void]$sb.AppendLine("|----------------|---------------------|")
                    [void]$sb.AppendLine("| Severity | ``$($m.hostBugSuspected.severity)`` |")
                    [void]$sb.AppendLine("| Status | **Expected** - host override is still required |")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine(":information_source: This is the expected failure mode. The ALC bug in upstream Lidarr has not been fixed yet.")
                  } elseif ($isKnownDiscovery) {
                    # Discovery disabled - different issue
                    [void]$sb.AppendLine("### :warning: DIFFERENT FAILURE: Plugin Discovery Disabled")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine("| Classification | ``$classification`` |")
                    [void]$sb.AppendLine("|----------------|---------------------|")
                    [void]$sb.AppendLine("| Severity | ``$($m.hostBugSuspected.severity)`` |")
                    [void]$sb.AppendLine("| Status | **Unexpected** - not the usual ALC bug |")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine(":rotating_light: **This is NOT the expected ALC failure!** Plugin discovery may be disabled in this Lidarr build.")
                  } elseif ($isKnownABI) {
                    # ABI mismatch - needs rebuild
                    [void]$sb.AppendLine("### :warning: DIFFERENT FAILURE: ABI Mismatch")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine("| Classification | ``$classification`` |")
                    [void]$sb.AppendLine("|----------------|---------------------|")
                    [void]$sb.AppendLine("| Severity | ``$($m.hostBugSuspected.severity)`` |")
                    [void]$sb.AppendLine("| Status | **Unexpected** - plugins may need rebuild |")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine(":rotating_light: **This is NOT the expected ALC failure!** Plugins may need to be rebuilt against the new Lidarr version.")
                  } else {
                    # UNKNOWN classification - LOUD WARNING
                    [void]$sb.AppendLine("### :boom: UNKNOWN FAILURE CLASS - INVESTIGATE IMMEDIATELY")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine("| Classification | ``$($classification ?? 'UNCLASSIFIED')`` |")
                    [void]$sb.AppendLine("|----------------|---------------------|")
                    [void]$sb.AppendLine("| Severity | ``$($m.hostBugSuspected.severity ?? 'unknown')`` |")
                    [void]$sb.AppendLine("| Status | **UNKNOWN** - new failure mode detected |")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine(":rotating_light::rotating_light::rotating_light: **THIS IS A NEW/UNKNOWN FAILURE CLASS!** :rotating_light::rotating_light::rotating_light:")
                    [void]$sb.AppendLine("")
                    [void]$sb.AppendLine("The canary failed for a reason we haven't seen before. Check the diagnostics bundle immediately.")
                    if ($m.hostBugSuspected.matchedLine) {
                      [void]$sb.AppendLine("")
                      [void]$sb.AppendLine("Matched error line:")
                      [void]$sb.AppendLine("``````")
                      [void]$sb.AppendLine($m.hostBugSuspected.matchedLine)
                      [void]$sb.AppendLine("``````")
                    }
                  }
                } else {
                  # Failed but no hostBugSuspected - also needs investigation
                  [void]$sb.AppendLine("### :boom: CANARY FAILED WITHOUT HOST BUG DETECTION")
                  [void]$sb.AppendLine("")
                  [void]$sb.AppendLine(":rotating_light::rotating_light::rotating_light: **UNEXPECTED FAILURE MODE!** :rotating_light::rotating_light::rotating_light:")
                  [void]$sb.AppendLine("")
                  [void]$sb.AppendLine("The canary failed but no known host bug pattern was detected. This is unusual and requires investigation.")
                  [void]$sb.AppendLine("")
                  [void]$sb.AppendLine("Possible causes:")
                  [void]$sb.AppendLine("- Gate logic error (not a host bug)")
                  [void]$sb.AppendLine("- New failure pattern not yet classified")
                  [void]$sb.AppendLine("- Infrastructure issue (network, container, etc)")
                  [void]$sb.AppendLine("")
                  # Show first error from results if available
                  if ($m.results) {
                    $failedGate = $m.results | Where-Object { $_.outcome -eq 'failed' } | Select-Object -First 1
                    if ($failedGate -and $failedGate.errors) {
                      [void]$sb.AppendLine("First failed gate: ``$($failedGate.gate)`` for ``$($failedGate.plugin)``")
                      [void]$sb.AppendLine("")
                      [void]$sb.AppendLine("Error(s):")
                      foreach ($err in ($failedGate.errors | Select-Object -First 3)) {
                        [void]$sb.AppendLine("- $err")
                      }
                    }
                  }
                }
              }
            } catch {
              [void]$sb.AppendLine("| Result | :question: Parse error |")
              [void]$sb.AppendLine("")
              [void]$sb.AppendLine("### :warning: Failed to parse manifest")
              [void]$sb.AppendLine("Error: $_")
            }
          } else {
            [void]$sb.AppendLine("| Result | :x: No manifest |")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine("### :boom: NO MANIFEST GENERATED")
            [void]$sb.AppendLine("")
            [void]$sb.AppendLine(":rotating_light: The canary runner did not produce a manifest. This usually means a catastrophic failure before gates could run.")
          }

          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("---")
          [void]$sb.AppendLine("*Canary tests the latest plugins branch WITHOUT host override. When it passes, the ALC bug is fixed upstream.*")

          $sb.ToString() | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8

      - name: Collect canary diagnostics
        if: always()
        shell: bash
        run: |
          set +e
          mkdir -p .e2e-canary/diagnostics
          docker logs "$CONTAINER_NAME" --tail 2000 2>&1 > .e2e-canary/diagnostics/container.log || true
          docker inspect "$CONTAINER_NAME" > .e2e-canary/diagnostics/inspect.json 2>&1 || true
          docker rm -f "$CONTAINER_NAME" || true

      - name: Upload canary diagnostics
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-canary-diagnostics-${{ github.run_id }}
          path: .e2e-canary/diagnostics/
          if-no-files-found: warn
          retention-days: 7
