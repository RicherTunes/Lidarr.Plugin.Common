name: ðŸ”¥ Multi-Plugin Smoke Test

on:
  workflow_call:
    inputs:
      caller_plugin:
        description: 'The plugin that called this workflow (e.g., brainarr, qobuzarr, tidalarr)'
        required: true
        type: string
      lidarr_docker_version:
        description: 'Lidarr Docker image version (e.g., pr-plugins-2.14.2.4786)'
        required: false
        type: string
        default: 'pr-plugins-2.14.2.4786'
      test_plugins:
        description: 'Comma-separated list of plugins to test (default: all)'
        required: false
        type: string
        default: 'brainarr,qobuzarr,tidalarr'
      skip_caller_build:
        description: 'Skip building caller plugin (use artifact from previous job)'
        required: false
        type: boolean
        default: false
    secrets:
      SUBMODULES_TOKEN:
        required: false

env:
  DOTNET_VERSION: '6.0.x'
  LIDARR_DOCKER_VERSION: ${{ inputs.lidarr_docker_version }}

jobs:
  smoke-test:
    name: ðŸ”¥ Plugin Co-existence Test
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout Common Library
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Lidarr.Plugin.Common
          ref: main
          path: common
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Extract Lidarr Assemblies from Docker
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lidarr-assemblies

          echo "Pulling Lidarr Docker image: ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }}"
          docker pull ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }}

          # Create temporary container and extract assemblies
          CONTAINER_ID=$(docker create ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }})
          echo "Container ID: $CONTAINER_ID"

          # Copy Lidarr binaries
          docker cp "$CONTAINER_ID:/app" lidarr-app || docker cp "$CONTAINER_ID:/opt/Lidarr" lidarr-app
          docker rm "$CONTAINER_ID"

          # Find and copy required DLLs
          find lidarr-app -name "*.dll" -exec cp {} lidarr-assemblies/ \; 2>/dev/null || true

          echo "Extracted assemblies:"
          ls lidarr-assemblies/*.dll 2>/dev/null | wc -l | xargs -I {} echo "{} DLL files extracted"
          ls lidarr-assemblies/ 2>/dev/null | head -20 || true

      - name: Checkout Brainarr
        if: contains(inputs.test_plugins, 'brainarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Brainarr
          ref: main
          path: plugins/brainarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Checkout Qobuzarr
        if: contains(inputs.test_plugins, 'qobuzarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Qobuzarr
          ref: main
          path: plugins/qobuzarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Checkout Tidalarr
        if: contains(inputs.test_plugins, 'tidalarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Tidalarr
          ref: main
          path: plugins/tidalarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Copy Lidarr Assemblies to Plugin Locations
        shell: bash
        run: |
          set -euo pipefail

          # Each plugin expects Lidarr assemblies in specific locations
          # Copy extracted assemblies to where each plugin expects them

          # Qobuzarr expects: ext/Lidarr/_output/net6.0/
          if [ -d "plugins/qobuzarr" ]; then
            mkdir -p plugins/qobuzarr/ext/Lidarr/_output/net6.0
            cp lidarr-assemblies/*.dll plugins/qobuzarr/ext/Lidarr/_output/net6.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Qobuzarr"
          fi

          # Tidalarr expects: ext/Lidarr/_output/net6.0/
          if [ -d "plugins/tidalarr" ]; then
            mkdir -p plugins/tidalarr/ext/Lidarr/_output/net6.0
            cp lidarr-assemblies/*.dll plugins/tidalarr/ext/Lidarr/_output/net6.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Tidalarr"
          fi

          # Brainarr uses -p:LidarrPath so no copy needed, but create ext/Lidarr-docker for fallback
          if [ -d "plugins/brainarr" ]; then
            mkdir -p plugins/brainarr/ext/Lidarr-docker/_output/net8.0
            cp lidarr-assemblies/*.dll plugins/brainarr/ext/Lidarr-docker/_output/net8.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Brainarr"
          fi

      - name: Build Brainarr Plugin
        if: contains(inputs.test_plugins, 'brainarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/brainarr

          # Patch NuGet config if needed
          if [ -f "ext/lidarr.plugin.common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/lidarr.plugin.common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/lidarr.plugin.common/NuGet.config
          fi

          dotnet restore Brainarr.Plugin/Brainarr.Plugin.csproj \
            /p:TargetFramework=net6.0
          dotnet build Brainarr.Plugin/Brainarr.Plugin.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:LidarrPath="${{ github.workspace }}/lidarr-assemblies" \
            -p:PluginPackagingDisable=true \
            -m:1

          echo "Brainarr build complete"

      - name: Build Qobuzarr Plugin
        if: contains(inputs.test_plugins, 'qobuzarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/qobuzarr

          # Patch NuGet config if needed
          if [ -f "ext/Lidarr.Plugin.Common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/Lidarr.Plugin.Common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/Lidarr.Plugin.Common/NuGet.config
          fi

          # Qobuzarr uses hardcoded path ext/Lidarr/_output/net6.0
          # Define PLUGIN_PROTOCOL for plugins-branch compatibility (string Protocol instead of enum)
          dotnet restore Qobuzarr.csproj \
            /p:TargetFramework=net6.0
          dotnet build Qobuzarr.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:RunAnalyzersDuringBuild=false \
            -p:EnableNETAnalyzers=false \
            -p:DefineConstants=PLUGIN_PROTOCOL \
            -p:PluginPackagingDisable=true \
            -m:1

          echo "Qobuzarr build complete"

      - name: Build Tidalarr Plugin
        if: contains(inputs.test_plugins, 'tidalarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/tidalarr

          # Patch NuGet config if needed
          if [ -f "ext/Lidarr.Plugin.Common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/Lidarr.Plugin.Common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/Lidarr.Plugin.Common/NuGet.config
          fi

          # Tidalarr uses hardcoded path in HostBridge: ext/Lidarr/_output/net6.0
          # Build both the main plugin and the HostBridge
          dotnet restore src/Tidalarr/Tidalarr.csproj \
            /p:TargetFramework=net6.0
          dotnet restore src/Tidalarr.HostBridge/Tidalarr.HostBridge.csproj \
            /p:TargetFramework=net6.0
          dotnet build src/Tidalarr/Tidalarr.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:PluginPackagingDisable=true \
            -p:RunAnalyzersDuringBuild=false \
            -p:EnableNETAnalyzers=false \
            -p:TreatWarningsAsErrors=false \
            -m:1
          dotnet build src/Tidalarr.HostBridge/Tidalarr.HostBridge.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:PluginPackagingDisable=true \
            -p:RunAnalyzersDuringBuild=false \
            -p:EnableNETAnalyzers=false \
            -p:TreatWarningsAsErrors=false \
            -m:1

          echo "Tidalarr build complete"

      - name: Stage Plugin Artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p staged-plugins

          # Lidarr plugins branch expects flat structure: PluginName/plugin-files
          # NOT nested: Owner/PluginName/plugin-files

          # Stage Brainarr
          if [ -d "plugins/brainarr" ]; then
            mkdir -p staged-plugins/Brainarr
            DLL=$(find plugins/brainarr -name 'Lidarr.Plugin.Brainarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Brainarr/
              cp plugins/brainarr/plugin.json staged-plugins/Brainarr/ 2>/dev/null || true
              cp plugins/brainarr/manifest.json staged-plugins/Brainarr/ 2>/dev/null || true
              echo "âœ“ Staged Brainarr from: $DLL"
            fi
          fi

          # Stage Qobuzarr
          if [ -d "plugins/qobuzarr" ]; then
            mkdir -p staged-plugins/Qobuzarr
            DLL=$(find plugins/qobuzarr -name 'Lidarr.Plugin.Qobuzarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Qobuzarr/
              cp plugins/qobuzarr/plugin.json staged-plugins/Qobuzarr/ 2>/dev/null || true
              cp plugins/qobuzarr/manifest.json staged-plugins/Qobuzarr/ 2>/dev/null || true
              echo "âœ“ Staged Qobuzarr from: $DLL"
            fi
          fi

          # Stage Tidalarr
          if [ -d "plugins/tidalarr" ]; then
            mkdir -p staged-plugins/Tidalarr
            DLL=$(find plugins/tidalarr -name 'Lidarr.Plugin.Tidalarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Tidalarr/
              cp plugins/tidalarr/plugin.json staged-plugins/Tidalarr/ 2>/dev/null || true
              cp plugins/tidalarr/manifest.json staged-plugins/Tidalarr/ 2>/dev/null || true
              echo "âœ“ Staged Tidalarr from: $DLL"
            fi
          fi

          echo ""
          echo "=== Staged Plugins ==="
          find staged-plugins -type f -name "*.dll" -o -name "*.json" | sort

      - name: Verify Plugin Assembly Loading (Co-existence Test)
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Plugin Assembly Co-existence Test ==="
          echo ""
          echo "This test verifies that all plugin DLLs can be loaded together"
          echo "without assembly conflicts (the core goal of ILRepack internalization)."
          echo ""

          # Create a test script to load all assemblies using MetadataLoadContext
          # This allows inspecting assemblies without loading their dependencies
          cat > test-assemblies.cs << 'CSHARP_EOF'
          using System;
          using System.IO;
          using System.Reflection;
          using System.Linq;
          using System.Reflection.Metadata;
          using System.Reflection.PortableExecutable;

          class AssemblyCoexistenceTest
          {
              static int Main(string[] args)
              {
                  Console.WriteLine("=== Assembly Co-existence Test ===");
                  Console.WriteLine();
                  Console.WriteLine("This test verifies that ILRepack internalization works correctly");
                  Console.WriteLine("by checking that each plugin is self-contained without duplicate");
                  Console.WriteLine("public types that would cause conflicts.");
                  Console.WriteLine();

                  var pluginsDir = args.Length > 0 ? args[0] : "staged-plugins";
                  var pluginDlls = Directory.GetFiles(pluginsDir, "Lidarr.Plugin.*.dll", SearchOption.AllDirectories);

                  if (pluginDlls.Length == 0)
                  {
                      Console.WriteLine("ERROR: No plugin DLLs found in " + pluginsDir);
                      return 1;
                  }

                  Console.WriteLine($"Found {pluginDlls.Length} plugin assemblies:");
                  foreach (var dll in pluginDlls)
                  {
                      var size = new FileInfo(dll).Length / 1024;
                      Console.WriteLine($"  - {Path.GetFileName(dll)} ({size} KB)");
                  }
                  Console.WriteLine();

                  var errors = new System.Collections.Generic.List<string>();
                  var allExportedTypes = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>>();
                  var assemblyInfo = new System.Collections.Generic.List<(string name, string version, long size)>();

                  // Analyze each assembly using metadata readers (no runtime loading)
                  foreach (var dll in pluginDlls)
                  {
                      Console.WriteLine($"Analyzing: {Path.GetFileName(dll)}");
                      try
                      {
                          using var stream = File.OpenRead(dll);
                          using var peReader = new PEReader(stream);
                          var metadataReader = peReader.GetMetadataReader();

                          // Get assembly name and version
                          var assemblyDef = metadataReader.GetAssemblyDefinition();
                          var assemblyName = metadataReader.GetString(assemblyDef.Name);
                          var version = assemblyDef.Version.ToString();
                          var size = new FileInfo(dll).Length;

                          assemblyInfo.Add((assemblyName, version, size));
                          Console.WriteLine($"  âœ“ Assembly: {assemblyName} v{version}");

                          // Count type definitions
                          var typeCount = metadataReader.TypeDefinitions.Count;
                          Console.WriteLine($"  âœ“ Contains {typeCount} types");

                          // Check for exported (public) types from common libraries
                          // These should be internalized if ILRepack worked correctly
                          var exportedTypes = new System.Collections.Generic.List<string>();
                          foreach (var typeHandle in metadataReader.TypeDefinitions)
                          {
                              var typeDef = metadataReader.GetTypeDefinition(typeHandle);
                              var typeName = metadataReader.GetString(typeDef.Name);
                              var ns = metadataReader.GetString(typeDef.Namespace);
                              var fullName = string.IsNullOrEmpty(ns) ? typeName : $"{ns}.{typeName}";

                              // Check visibility - TypeAttributes.VisibilityMask & Public
                              var attrs = typeDef.Attributes;
                              var isPublic = (attrs & TypeAttributes.VisibilityMask) == TypeAttributes.Public;

                              if (isPublic)
                              {
                                  exportedTypes.Add(fullName);

                                  // Track for conflict detection
                                  if (!allExportedTypes.ContainsKey(fullName))
                                      allExportedTypes[fullName] = new System.Collections.Generic.List<string>();
                                  allExportedTypes[fullName].Add(assemblyName);
                              }
                          }
                          Console.WriteLine($"  âœ“ Public types: {exportedTypes.Count}");
                      }
                      catch (Exception ex)
                      {
                          errors.Add($"{Path.GetFileName(dll)}: {ex.Message}");
                          Console.WriteLine($"  âœ— Failed to analyze: {ex.Message}");
                      }
                  }

                  Console.WriteLine();
                  Console.WriteLine("=== Checking for Type Conflicts ===");

                  // Find types that appear in multiple assemblies (would indicate conflict)
                  var conflicts = allExportedTypes
                      .Where(kv => kv.Value.Count > 1)
                      .Select(kv => $"Type '{kv.Key}' found in: {string.Join(", ", kv.Value)}")
                      .ToList();

                  if (conflicts.Any())
                  {
                      Console.WriteLine($"âœ— Found {conflicts.Count} type conflict(s):");
                      foreach (var conflict in conflicts.Take(20))
                          Console.WriteLine($"  - {conflict}");

                      // Determine if these are expected or problematic
                      var lidarrConflicts = conflicts.Where(c => c.Contains("Lidarr.")).ToList();
                      var pollyConflicts = conflicts.Where(c => c.Contains("Polly")).ToList();

                      if (lidarrConflicts.Any() || pollyConflicts.Any())
                      {
                          Console.WriteLine();
                          Console.WriteLine("âš  WARNING: Shared library types found in multiple plugins!");
                          Console.WriteLine("  This indicates ILRepack internalization may not be working.");
                          errors.AddRange(conflicts.Take(5));
                      }
                  }
                  else
                  {
                      Console.WriteLine("âœ“ No type conflicts detected");
                      Console.WriteLine("  Each plugin has unique public types (ILRepack internalization working)");
                  }

                  Console.WriteLine();
                  Console.WriteLine("=== Summary ===");
                  Console.WriteLine($"Assemblies analyzed: {assemblyInfo.Count}/{pluginDlls.Length}");

                  foreach (var (name, ver, sz) in assemblyInfo)
                      Console.WriteLine($"  - {name} v{ver} ({sz/1024} KB)");

                  Console.WriteLine($"Type conflicts: {conflicts.Count}");
                  Console.WriteLine($"Errors: {errors.Count}");

                  if (errors.Any())
                  {
                      Console.WriteLine();
                      Console.WriteLine("FAILED: Issues detected");
                      return 1;
                  }

                  Console.WriteLine();
                  Console.WriteLine("ðŸŽ‰ SUCCESS: All plugins can co-exist without conflicts!");
                  return 0;
              }
          }
          CSHARP_EOF

          # Compile and run the test
          echo "Compiling co-existence test..."
          dotnet new console -n AssemblyTest -o /tmp/assembly-test --force
          cp test-assemblies.cs /tmp/assembly-test/Program.cs

          # Update csproj with required package references
          cat > /tmp/assembly-test/AssemblyTest.csproj << 'CSPROJ_EOF'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net6.0</TargetFramework>
              <ImplicitUsings>disable</ImplicitUsings>
              <Nullable>disable</Nullable>
            </PropertyGroup>
            <ItemGroup>
              <PackageReference Include="System.Reflection.Metadata" Version="8.0.0" />
            </ItemGroup>
          </Project>
          CSPROJ_EOF

          cd /tmp/assembly-test
          dotnet build --configuration Release -v q

          echo ""
          echo "Running co-existence test..."
          echo ""
          dotnet run --configuration Release --no-build -- "${{ github.workspace }}/staged-plugins"

      - name: Verify Plugin Build Artifacts
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Verifying Plugin Build Artifacts ==="
          echo ""

          # Check each plugin has required files
          PLUGINS_TO_CHECK="${{ inputs.test_plugins }}"
          IFS=',' read -ra PLUGIN_ARRAY <<< "$PLUGINS_TO_CHECK"

          FAILED=0
          for plugin in "${PLUGIN_ARRAY[@]}"; do
            plugin_name=$(echo "$plugin" | xargs)
            plugin_cap=$(echo "$plugin_name" | sed 's/.*/\u&/')
            plugin_dir="staged-plugins/${plugin_cap}"

            echo "Checking $plugin_cap..."

            if [ ! -d "$plugin_dir" ]; then
              echo "  âœ— Directory not found: $plugin_dir"
              FAILED=1
              continue
            fi

            # Check for main DLL
            DLL_COUNT=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" | wc -l)
            if [ "$DLL_COUNT" -eq 0 ]; then
              echo "  âœ— No plugin DLL found"
              FAILED=1
            else
              DLL_NAME=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" -exec basename {} \;)
              DLL_SIZE=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" -exec stat -c%s {} \;)
              echo "  âœ“ Plugin DLL: $DLL_NAME ($DLL_SIZE bytes)"
            fi

            # Check for plugin.json
            if [ -f "$plugin_dir/plugin.json" ]; then
              VERSION=$(grep -oP '"version"\s*:\s*"\K[^"]+' "$plugin_dir/plugin.json" 2>/dev/null || echo "unknown")
              echo "  âœ“ plugin.json (version: $VERSION)"
            else
              echo "  âš  plugin.json not found (optional)"
            fi

            # Check for manifest.json
            if [ -f "$plugin_dir/manifest.json" ]; then
              echo "  âœ“ manifest.json present"
            else
              echo "  âš  manifest.json not found (optional)"
            fi
          done

          echo ""
          if [ $FAILED -eq 0 ]; then
            echo "ðŸŽ‰ All plugin artifacts verified successfully!"
          else
            echo "âœ— Some plugins missing required files"
            exit 1
          fi

      - name: Capture Debug Info on Failure
        if: failure()
        shell: bash
        run: |
          echo "=== Staged Plugin Contents ==="
          find staged-plugins -type f -exec ls -la {} \; 2>&1 || true

          echo ""
          echo "=== Plugin Directory Structure ==="
          find staged-plugins -type d 2>&1 || true

          echo ""
          echo "=== Build Output Directories ==="
          find plugins -path '*/bin/*' -name '*.dll' 2>&1 | head -50 || true
