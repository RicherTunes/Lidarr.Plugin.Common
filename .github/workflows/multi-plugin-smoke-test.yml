name: Multi-Plugin Smoke Test

on:
  workflow_dispatch:
    inputs:
      test_plugins:
        description: "Comma-separated plugins to build/mount (qobuzarr,tidalarr,brainarr). Default: qobuzarr,tidalarr"
        required: true
        default: qobuzarr,tidalarr
      caller_plugin:
        description: Optional caller plugin name (for reusable workflow callers)
        required: false
        default: ""
      lidarr_tag:
        description: Lidarr Docker tag (plugins branch; must support net8 plugins)
        required: true
        default: pr-plugins-3.1.1.4884
      qobuzarr_ref:
        description: Qobuzarr branch/tag/SHA
        required: true
        default: main
      tidalarr_ref:
        description: Tidalarr branch/tag/SHA
        required: true
        default: main
      brainarr_ref:
        description: Brainarr branch/tag/SHA (optional; defaults to caller SHA if called from Brainarr)
        required: false
        default: main
      run_medium_gate:
        description: Configure + test indexers (requires credentials)
        type: boolean
        required: true
        default: false
      run_downloadclient_gate:
        description: Configure + test download clients (requires credentials)
        type: boolean
        required: true
        default: false
      run_search_gate:
        description: Run AlbumSearch + require releases (requires credentials)  
        type: boolean
        required: true
        default: false
      run_grab_gate:
        description: POST /api/v1/release to queue downloads (requires credentials)
        type: boolean
        required: true
        default: false
      require_downloaded_files:
        description: Require at least one downloaded file on disk (grab gate only; slow)
        type: boolean
        required: true
        default: false
      grab_timeout_seconds:
        description: Timeout for grab gate queue/files checks
        type: string
        required: true
        default: "300"
      require_all_indexers_in_search:
        description: Fail search unless releases include each configured indexer name
        type: boolean
        required: true
        default: false
      run_canary:
        description: Also run against moving tag "pr-plugins" (allowed to fail)
        type: boolean
        required: true
        default: false
      run_golden_persist_gate:
        description: Restart container and verify persistence (requires grab gate)
        type: boolean
        required: false
        default: false
      run_authfail_redaction_gate:
        description: Test auth failure handling and log redaction (no creds needed)
        type: boolean
        required: false
        default: false
      run_drift_sentinel_gate:
        description: Validate stub-vs-live API field expectations (nightly only)
        type: boolean
        required: false
        default: false
      drift_sentinel_fail_on_drift:
        description: Fail if drift detected (warning mode if false)
        type: boolean
        required: false
        default: false
      drift_sentinel_include_success_mode:
        description: Also validate authenticated success payloads (requires credentials)
        type: boolean
        required: false
        default: false
      e2e_mode:
        description: "E2E mode: hermetic (stubbed, PR-safe) or live (real APIs, nightly)"
        type: choice
        required: false
        default: live
        options:
          - live
          - hermetic

  workflow_call:
    inputs:
      test_plugins:
        description: "Comma-separated plugins to build/mount (qobuzarr,tidalarr,brainarr). Default: qobuzarr,tidalarr"
        type: string
        required: false
        default: qobuzarr,tidalarr
      caller_plugin:
        description: Optional caller plugin name (e.g., brainarr) to default that plugin ref to the caller SHA
        type: string
        required: false
        default: ""
      lidarr_tag:
        description: Lidarr Docker tag (plugins branch; must support net8 plugin hosts)
        type: string
        required: false
        default: pr-plugins-3.1.1.4884
      qobuzarr_ref:
        description: Qobuzarr branch/tag/SHA
        type: string
        required: false
        default: main
      tidalarr_ref:
        description: Tidalarr branch/tag/SHA
        type: string
        required: false
        default: main
      brainarr_ref:
        description: Brainarr branch/tag/SHA (defaults to caller SHA if called from Brainarr)
        type: string
        required: false
        default: ""
      run_medium_gate:
        description: Configure + test indexers (requires credentials)
        type: boolean
        required: false
        default: false
      run_downloadclient_gate:
        description: Configure + test download clients (requires credentials)
        type: boolean
        required: false
        default: false
      run_search_gate:
        description: Run AlbumSearch + require releases (requires credentials)
        type: boolean
        required: false
        default: false
      run_grab_gate:
        description: POST /api/v1/release to queue downloads (requires credentials)
        type: boolean
        required: false
        default: false
      require_downloaded_files:
        description: Require at least one downloaded file on disk (grab gate only; slow)
        type: boolean
        required: false
        default: false
      grab_timeout_seconds:
        description: Timeout for grab gate queue/files checks
        type: string
        required: false
        default: "300"
      require_all_indexers_in_search:
        description: Fail search unless releases include each configured indexer name
        type: boolean
        required: false
        default: false
      run_canary:
        description: Also run against moving tag "pr-plugins" (allowed to fail)
        type: boolean
        required: false
        default: false
      run_golden_persist_gate:
        description: Restart container and verify persistence (requires grab gate)
        type: boolean
        required: false
        default: false
      run_authfail_redaction_gate:
        description: Test auth failure handling and log redaction (no creds needed)
        type: boolean
        required: false
        default: false
      run_drift_sentinel_gate:
        description: Validate stub-vs-live API field expectations (nightly only)
        type: boolean
        required: false
        default: false
      drift_sentinel_fail_on_drift:
        description: Fail if drift detected (warning mode if false)
        type: boolean
        required: false
        default: false
      drift_sentinel_include_success_mode:
        description: Also validate authenticated success payloads (requires credentials)
        type: boolean
        required: false
        default: false
      e2e_mode:
        description: "E2E mode: hermetic (stubbed, PR-safe) or live (real APIs, nightly)"
        type: string
        required: false
        default: live
    secrets:
      CROSS_REPO_PAT:
        required: true
      QOBUZARR_EMAIL:
        required: false
      QOBUZARR_PASSWORD:
        required: false
      QOBUZARR_USER_ID:
        required: false
      QOBUZARR_AUTH_TOKEN:
        required: false
      QOBUZARR_APP_ID:
        required: false
      QOBUZARR_APP_SECRET:
        required: false
      QOBUZARR_COUNTRY_CODE:
        required: false
      QOBUZ_EMAIL:
        required: false
      QOBUZ_PASSWORD:
        required: false
      QOBUZ_USER_ID:
        required: false
      QOBUZ_AUTH_TOKEN:
        required: false
      QOBUZ_APP_ID:
        required: false
      QOBUZ_APP_SECRET:
        required: false
      QOBUZ_COUNTRY_CODE:
        required: false
      TIDALARR_REDIRECT_URL:
        required: false
      TIDALARR_MARKET:
        required: false
      TIDALARR_CLIENT_ID:
        required: false
      TIDALARR_CLIENT_SECRET:
        required: false
      TIDAL_REDIRECT_URL:
        required: false
      TIDAL_MARKET:
        required: false
      TIDAL_CLIENT_ID:
        required: false
      TIDAL_CLIENT_SECRET:
        required: false

permissions:
  contents: read

env:
  DOTNET_NOLOGO: "true"
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"

jobs:
  smoke-test:
    name: Smoke Test (${{ matrix.name }})
    continue-on-error: ${{ matrix.allow_failure }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(format('{{"include":[{{"name":"gate","lidarr_tag":"{0}","allow_failure":false,"port":8689}}{1}]}}', inputs.lidarr_tag, ((inputs.run_canary == true || inputs.run_canary == 'true') && ',{"name":"canary","lidarr_tag":"pr-plugins","allow_failure":true,"port":8690}' || ''))) }}
    steps:
      - name: Preflight - Validate CROSS_REPO_PAT secret
        id: pat
        shell: bash
        env:
          CROSS_REPO_PAT: ${{ secrets.CROSS_REPO_PAT }}
        run: |
          set -euo pipefail
          echo "::add-mask::${CROSS_REPO_PAT:-}"

          if [[ -z "${CROSS_REPO_PAT:-}" ]]; then
            echo "::notice::Multi-plugin smoke test skipped: CROSS_REPO_PAT secret is missing or empty."
            echo ""
            echo "This workflow requires a Personal Access Token with 'repo' scope to checkout"
            echo "the plugin repositories (Qobuzarr/Tidalarr/Brainarr)."
            echo ""
            echo "To fix this:"
            echo "  1. Go to: https://github.com/settings/tokens"
            echo "  2. Create a PAT (classic) with 'repo' scope"
            echo "  3. Add repo secret named 'CROSS_REPO_PAT' in the CALLER repo:"
            echo "     Settings -> Secrets and variables -> Actions"
            echo "  4. Re-run the workflow"
            echo ""
            echo "See docs/MULTI_PLUGIN_SMOKE_TEST.md for full setup instructions."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=missing_cross_repo_pat" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Health check: verify PAT is valid and has correct scopes
          echo "Verifying CROSS_REPO_PAT health..."
          response=$(curl -s -w "\n%{http_code}" -H "Authorization: token ${CROSS_REPO_PAT}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/user" 2>/dev/null || echo -e "\n000")

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | sed '$d')

          if [[ "$http_code" == "401" ]]; then
            echo "::error::CROSS_REPO_PAT is expired or invalid (HTTP 401)."
            echo "The token may have expired. Please generate a new PAT and update the secret."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=pat_expired" >> "$GITHUB_OUTPUT"
            exit 0
          elif [[ "$http_code" == "403" ]]; then
            echo "::error::CROSS_REPO_PAT has insufficient permissions (HTTP 403)."
            echo "Ensure the token has 'repo' scope for cross-repository access."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "reason=pat_insufficient_scope" >> "$GITHUB_OUTPUT"
            exit 0
          elif [[ "$http_code" != "200" ]]; then
            echo "::warning::CROSS_REPO_PAT health check failed (HTTP $http_code). Proceeding anyway."
          else
            username=$(echo "$body" | grep -o '"login":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "PAT validated: authenticated as ${username:-unknown}"
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "CROSS_REPO_PAT secret is configured and valid"

      - name: Smoke Test Skipped
        if: ${{ steps.pat.outputs.skip == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "::notice::Skipping multi-plugin smoke test (reason: ${{ steps.pat.outputs.reason }})."

      - name: Checkout Lidarr.Plugin.Common
        if: ${{ steps.pat.outputs.skip != 'true' }}
        uses: actions/checkout@v4

      - name: Setup .NET SDKs
        if: ${{ steps.pat.outputs.skip != 'true' }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            8.0.x

      - name: Resolve plugin selection and refs
        if: ${{ steps.pat.outputs.skip != 'true' }}
        id: plugin_meta
        shell: bash
        env:
          INPUT_TEST_PLUGINS: ${{ inputs.test_plugins }}
          INPUT_CALLER_PLUGIN: ${{ inputs.caller_plugin }}
          INPUT_BRAINARR_REF: ${{ inputs.brainarr_ref }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail

          plugins="${INPUT_TEST_PLUGINS:-qobuzarr,tidalarr}"
          plugins_lc="$(echo "$plugins" | tr '[:upper:]' '[:lower:]' | tr -d ' ' | tr ';' ',')"

          include_qobuzarr=false
          include_tidalarr=false
          include_brainarr=false

          if echo ",$plugins_lc," | grep -q ",qobuzarr,"; then include_qobuzarr=true; fi
          if echo ",$plugins_lc," | grep -q ",tidalarr,"; then include_tidalarr=true; fi
          if echo ",$plugins_lc," | grep -q ",brainarr,"; then include_brainarr=true; fi

          echo "include_qobuzarr=$include_qobuzarr" >> "$GITHUB_OUTPUT"
          echo "include_tidalarr=$include_tidalarr" >> "$GITHUB_OUTPUT"
          echo "include_brainarr=$include_brainarr" >> "$GITHUB_OUTPUT"

          brainarr_ref="${INPUT_BRAINARR_REF:-}"
          if [[ -z "$brainarr_ref" ]]; then
            caller_lc="$(echo "${INPUT_CALLER_PLUGIN:-}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')"
            if [[ "$caller_lc" == "brainarr" || "$GITHUB_REPOSITORY" == "RicherTunes/Brainarr" ]]; then
              brainarr_ref="$GITHUB_SHA"
            else
              brainarr_ref="main"
            fi
          fi

          echo "brainarr_ref=$brainarr_ref" >> "$GITHUB_OUTPUT"
          echo "plugins=$plugins_lc" >> "$GITHUB_OUTPUT"

      - name: Checkout Qobuzarr
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_qobuzarr == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Qobuzarr
          ref: ${{ inputs.qobuzarr_ref }}
          path: qobuzarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Tidalarr
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_tidalarr == 'true' }}   
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Tidalarr
          ref: ${{ inputs.tidalarr_ref }}
          path: tidalarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Brainarr
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_brainarr == 'true' }}   
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Brainarr
          ref: ${{ steps.plugin_meta.outputs.brainarr_ref }}
          path: brainarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Extract Lidarr assemblies from Docker image
        if: ${{ steps.pat.outputs.skip != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Extracting Lidarr assemblies from plugins branch Docker image..."

          IMAGE="ghcr.io/hotio/lidarr:${{ matrix.lidarr_tag }}"
          echo "Pulling $IMAGE (with retry)"

          n=0
          until [ "$n" -ge 3 ]; do
            docker pull "$IMAGE" && break
            n=$((n+1))
            echo "Pull failed ($n). Retrying in 10s..." && sleep 10
          done

          if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "ghcr.io/hotio/lidarr:${{ matrix.lidarr_tag }}"; then
            echo "::error::Failed to pull Docker image $IMAGE after 3 attempts"
            exit 1
          fi

          echo "Creating temporary container..."
          cid=$(docker create "$IMAGE")

          echo "Extracting assemblies from container..."
          mkdir -p _lidarr_extracted
          docker cp "$cid:/app" _lidarr_extracted/ 2>/dev/null || docker cp "$cid:/opt/lidarr" _lidarr_extracted/ 2>/dev/null || {
            echo "::error::Could not extract from /app or /opt/lidarr"
            docker rm "$cid" >/dev/null
            exit 1
          }
          docker rm "$cid" >/dev/null

          echo "Copying assemblies to plugin ext directories..."

          targets=()
          if [[ "${{ steps.plugin_meta.outputs.include_qobuzarr }}" == "true" ]]; then targets+=(qobuzarr); fi
          if [[ "${{ steps.plugin_meta.outputs.include_tidalarr }}" == "true" ]]; then targets+=(tidalarr); fi
          if [[ "${{ steps.plugin_meta.outputs.include_brainarr }}" == "true" ]]; then targets+=(brainarr); fi

          if [[ ${#targets[@]} -eq 0 ]]; then
            echo "::error::No test plugins selected (test_plugins='${{ steps.plugin_meta.outputs.plugins }}')."
            exit 1
          fi

          for plugin_dir in "${targets[@]}"; do
            mkdir -p "$plugin_dir/ext/Lidarr/_output/net8.0"
            find _lidarr_extracted -type f -name "*.dll" -exec cp {} "$plugin_dir/ext/Lidarr/_output/net8.0/" \;
          done

          # Verify critical assemblies exist
          for plugin_dir in "${targets[@]}"; do
            if [ ! -f "$plugin_dir/ext/Lidarr/_output/net8.0/Lidarr.dll" ]; then
              echo "::error::Missing Lidarr.dll in $plugin_dir after extraction"
              ls -la "$plugin_dir/ext/Lidarr/_output/net8.0/" || true
              exit 1
            fi
          done

          echo "Assembly extraction complete:"
          ls -la qobuzarr/ext/Lidarr/_output/net8.0/Lidarr*.dll || true

          # Cleanup
          rm -rf _lidarr_extracted

      - name: Sync tools from main checkout to submodules
        if: ${{ steps.pat.outputs.skip != 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Syncing tools and build assets from main checkout to plugin submodules..."

          # Plugins have a Common submodule (path differs by repo casing)
          # The submodules may point to older commits, so we sync from this checkout
          for plugin_dir in qobuzarr tidalarr brainarr; do
            if [ ! -d "$plugin_dir" ]; then
              continue
            fi

            if [ "$plugin_dir" = "brainarr" ]; then
              submod_common="$plugin_dir/ext/lidarr.plugin.common"
            else
              submod_common="$plugin_dir/ext/Lidarr.Plugin.Common"
            fi
            if [ -d "$submod_common" ]; then
              echo "Syncing to $submod_common..."

              # Sync tools directory (includes ManifestCheck.ps1, PluginPack.psm1)
              if [ -d "tools" ]; then
                rm -rf "$submod_common/tools"
                cp -r tools "$submod_common/tools"
                echo "  - tools/ synced"
              fi

              # Sync build directory (includes PluginPackaging.targets)
              if [ -d "build" ]; then
                rm -rf "$submod_common/build"
                cp -r build "$submod_common/build"
                echo "  - build/ synced"
              fi
            else
              echo "Warning: $submod_common not found, skipping sync"
            fi
          done

          echo "Tool sync complete"

      - name: Build Qobuzarr package
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_qobuzarr == 'true' }}   
        shell: pwsh
        working-directory: qobuzarr
        run: |
          $buildSuccess = $false
          try {
            ./build.ps1 -Configuration Release -Restore -Package -VerboseOutput
            if ($LASTEXITCODE -eq 0) { $buildSuccess = $true }
          } catch {
            Write-Host "build.ps1 threw exception: $_" -ForegroundColor Red
          }
          if (-not $buildSuccess) {
            Write-Host ""
            Write-Host "::group::Detailed build error output"
            dotnet restore --verbosity quiet 2>&1 | Out-Null
            dotnet build Qobuzarr.csproj --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            Write-Host "::endgroup::"
            exit 1
          }

      - name: Build Tidalarr package
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_tidalarr == 'true' }}   
        shell: pwsh
        working-directory: tidalarr
        run: |
          $buildSuccess = $false
          try {
            ./build.ps1 -Configuration Release -Restore -Package -VerboseOutput
            if ($LASTEXITCODE -eq 0) { $buildSuccess = $true }
          } catch {
            Write-Host "build.ps1 threw exception: $_" -ForegroundColor Red
          }
          if (-not $buildSuccess) {
            Write-Host ""
            Write-Host "::group::Detailed build error output"
            dotnet restore --verbosity quiet 2>&1 | Out-Null
            $csproj = Get-ChildItem -Filter "*.csproj" | Where-Object { $_.Name -notmatch "Tests" } | Select-Object -First 1
            if ($csproj) {
              dotnet build $csproj.Name --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            } else {
              dotnet build --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            }
            Write-Host "::endgroup::"
            exit 1
          }

      - name: Build Brainarr package
        if: ${{ steps.pat.outputs.skip != 'true' && steps.plugin_meta.outputs.include_brainarr == 'true' }}
        shell: pwsh
        working-directory: brainarr
        run: |
          $buildSuccess = $false
          try {
            ./build.ps1 -Configuration Release -Restore -Package -VerboseOutput
            if ($LASTEXITCODE -eq 0) { $buildSuccess = $true }
          } catch {
            Write-Host "build.ps1 threw exception: $_" -ForegroundColor Red
          }
          if (-not $buildSuccess) {
            Write-Host ""
            Write-Host "::group::Detailed build error output"
            dotnet restore --verbosity quiet 2>&1 | Out-Null
            dotnet build Brainarr.sln --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            Write-Host "::endgroup::"
            exit 1
          }

      - name: Locate plugin zips
        if: ${{ steps.pat.outputs.skip != 'true' }}
        shell: pwsh
        run: |
          function Find-PluginZip {
            param(
              [Parameter(Mandatory=$true)][string]$RepoDir,
              [Parameter(Mandatory=$true)][string]$NamePattern
            )

            $root = Resolve-Path $RepoDir

            # Strategy 1: Prefer plugin.json-adjacent zips (canonical build output)
            $manifestFiles = Get-ChildItem -Path $root -Recurse -File -Filter 'plugin.json' -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' }

            foreach ($manifest in $manifestFiles) {
              $dir = $manifest.DirectoryName
              $adjacentZips = Get-ChildItem -Path $dir -File -Filter '*.zip' -ErrorAction SilentlyContinue |
                Where-Object { $_.Name -match $NamePattern } |
                Sort-Object LastWriteTimeUtc -Descending
              $zip = $adjacentZips | Select-Object -First 1
              if ($zip) {
                Write-Host "Found plugin.json-adjacent zip: $($zip.FullName)"
                return $zip.FullName
              }
            }

            # Strategy 2: Fallback to latest zip anywhere (legacy/fallback)
            Write-Host "No plugin.json-adjacent zip found, falling back to latest zip search..."
            $candidates = Get-ChildItem -Path $root -Recurse -File -Filter '*.zip' -ErrorAction Stop |
              Where-Object {
                $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' -and
                $_.Name -match $NamePattern
              } |
              Sort-Object LastWriteTimeUtc -Descending

            $zip = $candidates | Select-Object -First 1
            if (-not $zip) {
              throw "Could not find a zip for '$RepoDir' matching pattern '$NamePattern'."
            }
            Write-Host "Found fallback zip: $($zip.FullName)"
            return $zip.FullName
          }

          $qobuzZip = ""
          if ("${{ steps.plugin_meta.outputs.include_qobuzarr }}" -eq "true") {
            $qobuzZip = Find-PluginZip -RepoDir 'qobuzarr' -NamePattern 'Qobuzarr'
          }

          $tidalZip = ""
          if ("${{ steps.plugin_meta.outputs.include_tidalarr }}" -eq "true") {
            $tidalZip = Find-PluginZip -RepoDir 'tidalarr' -NamePattern 'Tidalarr'
          }

          $brainZip = ""
          if ("${{ steps.plugin_meta.outputs.include_brainarr }}" -eq "true") {
            $brainZip = Find-PluginZip -RepoDir 'brainarr' -NamePattern 'Brainarr'
          }

          "QOBUZ_ZIP=$qobuzZip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "TIDAL_ZIP=$tidalZip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "BRAIN_ZIP=$brainZip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          if (-not [string]::IsNullOrWhiteSpace($qobuzZip)) { Write-Host "Qobuzarr zip: $qobuzZip" }
          if (-not [string]::IsNullOrWhiteSpace($tidalZip)) { Write-Host "Tidalarr zip: $tidalZip" }
          if (-not [string]::IsNullOrWhiteSpace($brainZip)) { Write-Host "Brainarr zip: $brainZip" }

      - name: Validate credentials (if live gates enabled)
        if: ${{ steps.pat.outputs.skip != 'true' && (inputs.run_medium_gate || inputs.run_downloadclient_gate || inputs.run_search_gate || inputs.run_grab_gate || inputs.run_golden_persist_gate) }}
        shell: bash
        env:
          QOBUZARR_EMAIL: ${{ secrets.QOBUZARR_EMAIL }}
          QOBUZARR_PASSWORD: ${{ secrets.QOBUZARR_PASSWORD }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_APP_ID: ${{ secrets.QOBUZARR_APP_ID }}
          QOBUZARR_APP_SECRET: ${{ secrets.QOBUZARR_APP_SECRET }}
          QOBUZ_EMAIL: ${{ secrets.QOBUZ_EMAIL }}
          QOBUZ_PASSWORD: ${{ secrets.QOBUZ_PASSWORD }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_APP_ID: ${{ secrets.QOBUZ_APP_ID }}
          QOBUZ_APP_SECRET: ${{ secrets.QOBUZ_APP_SECRET }}
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_MARKET: ${{ secrets.TIDALARR_MARKET }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          TIDAL_MARKET: ${{ secrets.TIDAL_MARKET }}
        run: |
          set -euo pipefail

          has_qobuz_email=false
          if [[ -n "${QOBUZARR_EMAIL:-}" && -n "${QOBUZARR_PASSWORD:-}" ]]; then has_qobuz_email=true; fi
          if [[ -n "${QOBUZ_EMAIL:-}" && -n "${QOBUZ_PASSWORD:-}" ]]; then has_qobuz_email=true; fi

          has_qobuz_token=false
          if [[ -n "${QOBUZARR_USER_ID:-}" && -n "${QOBUZARR_AUTH_TOKEN:-}" ]]; then has_qobuz_token=true; fi
          if [[ -n "${QOBUZ_USER_ID:-}" && -n "${QOBUZ_AUTH_TOKEN:-}" ]]; then has_qobuz_token=true; fi

          has_tidal=false
          if [[ -n "${TIDALARR_REDIRECT_URL:-}" || -n "${TIDAL_REDIRECT_URL:-}" ]]; then has_tidal=true; fi

          if [[ "$has_qobuz_email" != "true" && "$has_qobuz_token" != "true" && "$has_tidal" != "true" ]]; then
            echo "Credentials are required for the selected gates, but no supported secret set was found."
            echo "Provide at least one provider credential set (Qobuz email/password or token; or Tidal redirect URL)."
            exit 1
          fi

      - name: Validate drift sentinel secrets (if strict success mode)
        if: ${{ steps.pat.outputs.skip != 'true' && inputs.run_drift_sentinel_gate && inputs.drift_sentinel_include_success_mode && inputs.drift_sentinel_fail_on_drift }}
        shell: bash
        env:
          QOBUZARR_APP_ID: ${{ secrets.QOBUZARR_APP_ID }}
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZ_APP_ID: ${{ secrets.QOBUZ_APP_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          TIDALARR_CLIENT_ID: ${{ secrets.TIDALARR_CLIENT_ID }}
          TIDALARR_CLIENT_SECRET: ${{ secrets.TIDALARR_CLIENT_SECRET }}
          TIDAL_CLIENT_ID: ${{ secrets.TIDAL_CLIENT_ID }}
          TIDAL_CLIENT_SECRET: ${{ secrets.TIDAL_CLIENT_SECRET }}
        run: |
          set -euo pipefail

          echo "Drift sentinel is in STRICT SUCCESS MODE."
          echo "Validating required secrets for authenticated probes..."

          # Check Qobuz credentials
          has_qobuz=false
          if [[ -n "${QOBUZARR_APP_ID:-}" ]] || [[ -n "${QOBUZ_APP_ID:-}" ]]; then
            has_qobuz=true
            echo "  ✓ Qobuz APP_ID configured"
          fi

          # Check Tidal client credentials
          has_tidal=false
          if [[ -n "${TIDALARR_CLIENT_ID:-}" && -n "${TIDALARR_CLIENT_SECRET:-}" ]]; then
            has_tidal=true
            echo "  ✓ Tidal client credentials (TIDALARR_*) configured"
          elif [[ -n "${TIDAL_CLIENT_ID:-}" && -n "${TIDAL_CLIENT_SECRET:-}" ]]; then
            has_tidal=true
            echo "  ✓ Tidal client credentials (TIDAL_*) configured"
          fi

          if [[ "$has_qobuz" != "true" && "$has_tidal" != "true" ]]; then
            echo ""
            echo "::error::Drift sentinel strict success mode requires credentials, but none found."
            echo ""
            echo "To fix, configure at least one of:"
            echo "  - QOBUZ_APP_ID (+ optionally QOBUZ_AUTH_TOKEN for search)"
            echo "  - TIDAL_CLIENT_ID + TIDAL_CLIENT_SECRET (for OAuth token acquisition)"
            echo ""
            echo "Or disable strict success mode:"
            echo "  - Set drift_sentinel_fail_on_drift: false (warning mode)"
            echo "  - Or set drift_sentinel_include_success_mode: false"
            exit 1
          fi

          echo "Drift sentinel secrets validation passed."

      - name: Run multi-plugin harness
        if: ${{ steps.pat.outputs.skip != 'true' }}
        shell: pwsh
        env:
          QOBUZARR_EMAIL: ${{ secrets.QOBUZARR_EMAIL }}
          QOBUZARR_PASSWORD: ${{ secrets.QOBUZARR_PASSWORD }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_APP_ID: ${{ secrets.QOBUZARR_APP_ID }}
          QOBUZARR_APP_SECRET: ${{ secrets.QOBUZARR_APP_SECRET }}
          QOBUZARR_COUNTRY_CODE: ${{ secrets.QOBUZARR_COUNTRY_CODE }}
          QOBUZ_EMAIL: ${{ secrets.QOBUZ_EMAIL }}
          QOBUZ_PASSWORD: ${{ secrets.QOBUZ_PASSWORD }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_APP_ID: ${{ secrets.QOBUZ_APP_ID }}
          QOBUZ_APP_SECRET: ${{ secrets.QOBUZ_APP_SECRET }}
          QOBUZ_COUNTRY_CODE: ${{ secrets.QOBUZ_COUNTRY_CODE }}
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_MARKET: ${{ secrets.TIDALARR_MARKET }}
          TIDALARR_CLIENT_ID: ${{ secrets.TIDALARR_CLIENT_ID }}
          TIDALARR_CLIENT_SECRET: ${{ secrets.TIDALARR_CLIENT_SECRET }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          TIDAL_MARKET: ${{ secrets.TIDAL_MARKET }}
          TIDAL_CLIENT_ID: ${{ secrets.TIDAL_CLIENT_ID }}
          TIDAL_CLIENT_SECRET: ${{ secrets.TIDAL_CLIENT_SECRET }}
        run: |
          $containerName = "lidarr-multi-${{ matrix.name }}-${{ github.run_id }}-${{ github.run_attempt }}"
          "SMOKE_CONTAINER_NAME=$containerName" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          $pluginZips = @()
          if (-not [string]::IsNullOrWhiteSpace($env:QOBUZ_ZIP)) { $pluginZips += "qobuzarr=$env:QOBUZ_ZIP" }
          if (-not [string]::IsNullOrWhiteSpace($env:TIDAL_ZIP)) { $pluginZips += "tidalarr=$env:TIDAL_ZIP" }
          if (-not [string]::IsNullOrWhiteSpace($env:BRAIN_ZIP)) { $pluginZips += "brainarr=$env:BRAIN_ZIP" }
          if ($pluginZips.Count -eq 0) {
            throw "No plugin zips were located. Check the build steps and the 'Locate plugin zips' output."
          }

          $params = @{
            LidarrTag = "${{ matrix.lidarr_tag }}"
            ContainerName = $containerName
            PluginZip = $pluginZips
            KeepRunning = $true
            Port = [int]"${{ matrix.port }}"
          }

          if ("${{ inputs.run_medium_gate }}" -eq "true") { $params.RunMediumGate = $true }
          if ("${{ inputs.run_downloadclient_gate }}" -eq "true") { $params.RunDownloadClientGate = $true }
          if ("${{ inputs.run_search_gate }}" -eq "true") { $params.RunSearchGate = $true }
          if ("${{ inputs.run_grab_gate }}" -eq "true") { $params.RunGrabGate = $true }
          if ("${{ inputs.require_downloaded_files }}" -eq "true") { $params.RequireDownloadedFiles = $true }
          if (-not [string]::IsNullOrWhiteSpace("${{ inputs.grab_timeout_seconds }}")) { $params.GrabTimeoutSeconds = [int]"${{ inputs.grab_timeout_seconds }}" }
          if ("${{ inputs.require_all_indexers_in_search }}" -eq "true") { $params.RequireAllConfiguredIndexersInSearch = $true }
          if ("${{ inputs.run_golden_persist_gate }}" -eq "true") { $params.RunGoldenPersistGate = $true }
          if ("${{ inputs.run_authfail_redaction_gate }}" -eq "true") { $params.RunAuthFailRedactionGate = $true }
          if ("${{ inputs.run_drift_sentinel_gate }}" -eq "true") { $params.RunDriftSentinelGate = $true }
          if ("${{ inputs.drift_sentinel_fail_on_drift }}" -eq "true") { $params.DriftSentinelFailOnDrift = $true }
          if ("${{ inputs.drift_sentinel_include_success_mode }}" -eq "true") { $params.DriftSentinelIncludeSuccessMode = $true }

          & ./scripts/multi-plugin-docker-smoke-test.ps1 @params

      - name: Collect container diagnostics
        if: ${{ always() && steps.pat.outputs.skip != 'true' }}
        shell: bash
        run: |
          set +e
          mkdir -p .docker-multi-smoke-test/diagnostics

          echo "::group::All containers (docker ps -a)"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" | tee .docker-multi-smoke-test/diagnostics/containers.txt || true
          echo "::endgroup::"

          if docker ps -a --format '{{.Names}}' | grep -q "^${SMOKE_CONTAINER_NAME:-}$"; then
            echo "::group::Container logs (${SMOKE_CONTAINER_NAME})"
            docker logs "${SMOKE_CONTAINER_NAME}" --tail 5000 2>&1 | tee .docker-multi-smoke-test/diagnostics/container.log || true
            echo "::endgroup::"

            echo "::group::Container inspect"
            docker inspect "${SMOKE_CONTAINER_NAME}" > .docker-multi-smoke-test/diagnostics/inspect.json 2> .docker-multi-smoke-test/diagnostics/inspect.error.txt || true
            echo "::endgroup::"

            docker rm -f "${SMOKE_CONTAINER_NAME}" || true
          else
            echo "Container ${SMOKE_CONTAINER_NAME:-<unknown>} not found"
          fi

      - name: Upload smoke artifacts
        if: ${{ always() && steps.pat.outputs.skip != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: multi-plugin-smoke-${{ matrix.name }}-artifacts
          path: |
            ${{ env.QOBUZ_ZIP }}
            ${{ env.TIDAL_ZIP }}
            ${{ env.BRAIN_ZIP }}
            .docker-multi-smoke-test/
          if-no-files-found: warn
