name: ðŸ”¥ Multi-Plugin Smoke Test

on:
  workflow_call:
    inputs:
      caller_plugin:
        description: 'The plugin that called this workflow (e.g., brainarr, qobuzarr, tidalarr)'
        required: true
        type: string
      lidarr_docker_version:
        description: 'Lidarr Docker image version (e.g., pr-plugins-2.14.2.4786)'
        required: false
        type: string
        default: 'pr-plugins-2.14.2.4786'
      test_plugins:
        description: 'Comma-separated list of plugins to test (default: all)'
        required: false
        type: string
        default: 'brainarr,qobuzarr,tidalarr'
      skip_caller_build:
        description: 'Skip building caller plugin (use artifact from previous job)'
        required: false
        type: boolean
        default: false
    secrets:
      SUBMODULES_TOKEN:
        required: false

env:
  DOTNET_VERSION: '6.0.x'
  LIDARR_DOCKER_VERSION: ${{ inputs.lidarr_docker_version }}

jobs:
  smoke-test:
    name: ðŸ”¥ Plugin Co-existence Test
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout Common Library
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Lidarr.Plugin.Common
          ref: main
          path: common
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Extract Lidarr Assemblies from Docker
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p lidarr-assemblies

          echo "Pulling Lidarr Docker image: ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }}"
          docker pull ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }}

          # Create temporary container and extract assemblies
          CONTAINER_ID=$(docker create ghcr.io/hotio/lidarr:${{ env.LIDARR_DOCKER_VERSION }})
          echo "Container ID: $CONTAINER_ID"

          # Copy Lidarr binaries
          docker cp "$CONTAINER_ID:/app" lidarr-app || docker cp "$CONTAINER_ID:/opt/Lidarr" lidarr-app
          docker rm "$CONTAINER_ID"

          # Find and copy required DLLs
          find lidarr-app -name "*.dll" -exec cp {} lidarr-assemblies/ \; 2>/dev/null || true

          echo "Extracted assemblies:"
          ls lidarr-assemblies/*.dll 2>/dev/null | wc -l | xargs -I {} echo "{} DLL files extracted"
          ls lidarr-assemblies/ 2>/dev/null | head -20 || true

      - name: Checkout Brainarr
        if: contains(inputs.test_plugins, 'brainarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Brainarr
          ref: main
          path: plugins/brainarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Checkout Qobuzarr
        if: contains(inputs.test_plugins, 'qobuzarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Qobuzarr
          ref: main
          path: plugins/qobuzarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Checkout Tidalarr
        if: contains(inputs.test_plugins, 'tidalarr')
        uses: actions/checkout@v4
        with:
          repository: RicherTunes/Tidalarr
          ref: main
          path: plugins/tidalarr
          submodules: recursive
          token: ${{ secrets.SUBMODULES_TOKEN || github.token }}

      - name: Copy Lidarr Assemblies to Plugin Locations
        shell: bash
        run: |
          set -euo pipefail

          # Each plugin expects Lidarr assemblies in specific locations
          # Copy extracted assemblies to where each plugin expects them

          # Qobuzarr expects: ext/Lidarr/_output/net6.0/
          if [ -d "plugins/qobuzarr" ]; then
            mkdir -p plugins/qobuzarr/ext/Lidarr/_output/net6.0
            cp lidarr-assemblies/*.dll plugins/qobuzarr/ext/Lidarr/_output/net6.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Qobuzarr"
          fi

          # Tidalarr expects: ext/Lidarr/_output/net6.0/
          if [ -d "plugins/tidalarr" ]; then
            mkdir -p plugins/tidalarr/ext/Lidarr/_output/net6.0
            cp lidarr-assemblies/*.dll plugins/tidalarr/ext/Lidarr/_output/net6.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Tidalarr"
          fi

          # Brainarr uses -p:LidarrPath so no copy needed, but create ext/Lidarr-docker for fallback
          if [ -d "plugins/brainarr" ]; then
            mkdir -p plugins/brainarr/ext/Lidarr-docker/_output/net8.0
            cp lidarr-assemblies/*.dll plugins/brainarr/ext/Lidarr-docker/_output/net8.0/ 2>/dev/null || true
            echo "âœ“ Copied assemblies for Brainarr"
          fi

      - name: Build Brainarr Plugin
        if: contains(inputs.test_plugins, 'brainarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/brainarr

          # Patch NuGet config if needed
          if [ -f "ext/lidarr.plugin.common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/lidarr.plugin.common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/lidarr.plugin.common/NuGet.config
          fi

          dotnet restore Brainarr.Plugin/Brainarr.Plugin.csproj \
            /p:TargetFramework=net6.0
          dotnet build Brainarr.Plugin/Brainarr.Plugin.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:LidarrPath="${{ github.workspace }}/lidarr-assemblies" \
            -m:1

          echo "Brainarr build complete"

      - name: Build Qobuzarr Plugin
        if: contains(inputs.test_plugins, 'qobuzarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/qobuzarr

          # Patch NuGet config if needed
          if [ -f "ext/Lidarr.Plugin.Common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/Lidarr.Plugin.Common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/Lidarr.Plugin.Common/NuGet.config
          fi

          # Qobuzarr uses hardcoded path ext/Lidarr/_output/net6.0
          # Define PLUGIN_PROTOCOL for plugins-branch compatibility (string Protocol instead of enum)
          dotnet restore Qobuzarr.csproj \
            /p:TargetFramework=net6.0
          dotnet build Qobuzarr.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -p:RunAnalyzersDuringBuild=false \
            -p:EnableNETAnalyzers=false \
            -p:DefineConstants=PLUGIN_PROTOCOL \
            -m:1

          echo "Qobuzarr build complete"

      - name: Build Tidalarr Plugin
        if: contains(inputs.test_plugins, 'tidalarr')
        shell: bash
        run: |
          set -euo pipefail
          cd plugins/tidalarr

          # Patch NuGet config if needed
          if [ -f "ext/Lidarr.Plugin.Common/NuGet.config" ]; then
            grep -q 'TagLibSharp-Lidarr' ext/Lidarr.Plugin.Common/NuGet.config || \
              sed -i '/<packageSource key="lidarr-taglib">/a \\      <package pattern="TagLibSharp-Lidarr*" />' ext/Lidarr.Plugin.Common/NuGet.config
          fi

          # Tidalarr uses hardcoded path in HostBridge: ext/Lidarr/_output/net6.0
          # Build both the main plugin and the HostBridge
          dotnet restore src/Tidalarr/Tidalarr.csproj \
            /p:TargetFramework=net6.0
          dotnet restore src/Tidalarr.HostBridge/Tidalarr.HostBridge.csproj \
            /p:TargetFramework=net6.0
          dotnet build src/Tidalarr/Tidalarr.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -m:1
          dotnet build src/Tidalarr.HostBridge/Tidalarr.HostBridge.csproj \
            --configuration Release \
            --no-restore \
            --framework net6.0 \
            -m:1

          echo "Tidalarr build complete"

      - name: Stage Plugin Artifacts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p staged-plugins

          # Lidarr plugins branch expects flat structure: PluginName/plugin-files
          # NOT nested: Owner/PluginName/plugin-files

          # Stage Brainarr
          if [ -d "plugins/brainarr" ]; then
            mkdir -p staged-plugins/Brainarr
            DLL=$(find plugins/brainarr -name 'Lidarr.Plugin.Brainarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Brainarr/
              cp plugins/brainarr/plugin.json staged-plugins/Brainarr/ 2>/dev/null || true
              cp plugins/brainarr/manifest.json staged-plugins/Brainarr/ 2>/dev/null || true
              echo "âœ“ Staged Brainarr from: $DLL"
            fi
          fi

          # Stage Qobuzarr
          if [ -d "plugins/qobuzarr" ]; then
            mkdir -p staged-plugins/Qobuzarr
            DLL=$(find plugins/qobuzarr -name 'Lidarr.Plugin.Qobuzarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Qobuzarr/
              cp plugins/qobuzarr/plugin.json staged-plugins/Qobuzarr/ 2>/dev/null || true
              cp plugins/qobuzarr/manifest.json staged-plugins/Qobuzarr/ 2>/dev/null || true
              echo "âœ“ Staged Qobuzarr from: $DLL"
            fi
          fi

          # Stage Tidalarr
          if [ -d "plugins/tidalarr" ]; then
            mkdir -p staged-plugins/Tidalarr
            DLL=$(find plugins/tidalarr -name 'Lidarr.Plugin.Tidalarr.dll' -path '*/bin/*' | head -1)
            if [ -n "$DLL" ]; then
              cp "$DLL" staged-plugins/Tidalarr/
              cp plugins/tidalarr/plugin.json staged-plugins/Tidalarr/ 2>/dev/null || true
              cp plugins/tidalarr/manifest.json staged-plugins/Tidalarr/ 2>/dev/null || true
              echo "âœ“ Staged Tidalarr from: $DLL"
            fi
          fi

          echo ""
          echo "=== Staged Plugins ==="
          find staged-plugins -type f -name "*.dll" -o -name "*.json" | sort

      - name: Verify Plugin Assembly Loading (Co-existence Test)
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Plugin Assembly Co-existence Test ==="
          echo ""
          echo "This test verifies that all plugin DLLs can be loaded together"
          echo "without assembly conflicts (the core goal of ILRepack internalization)."
          echo ""

          # Create a test script to load all assemblies
          cat > test-assemblies.cs << 'CSHARP_EOF'
          using System;
          using System.IO;
          using System.Reflection;
          using System.Linq;

          class AssemblyCoexistenceTest
          {
              static int Main(string[] args)
              {
                  Console.WriteLine("=== Assembly Co-existence Test ===");
                  Console.WriteLine();

                  var pluginsDir = args.Length > 0 ? args[0] : "staged-plugins";
                  var pluginDlls = Directory.GetFiles(pluginsDir, "Lidarr.Plugin.*.dll", SearchOption.AllDirectories);

                  if (pluginDlls.Length == 0)
                  {
                      Console.WriteLine("ERROR: No plugin DLLs found in " + pluginsDir);
                      return 1;
                  }

                  Console.WriteLine($"Found {pluginDlls.Length} plugin assemblies:");
                  foreach (var dll in pluginDlls)
                      Console.WriteLine($"  - {Path.GetFileName(dll)}");
                  Console.WriteLine();

                  var loadedAssemblies = new System.Collections.Generic.List<Assembly>();
                  var errors = new System.Collections.Generic.List<string>();

                  // Load all assemblies
                  foreach (var dll in pluginDlls)
                  {
                      try
                      {
                          Console.WriteLine($"Loading: {Path.GetFileName(dll)}");
                          var assembly = Assembly.LoadFrom(dll);
                          loadedAssemblies.Add(assembly);
                          Console.WriteLine($"  âœ“ Loaded successfully: {assembly.GetName().Name} v{assembly.GetName().Version}");

                          // Check for IPlugin implementations
                          var pluginTypes = assembly.GetTypes()
                              .Where(t => t.GetInterfaces().Any(i => i.Name == "IPlugin"))
                              .ToList();

                          if (pluginTypes.Any())
                              Console.WriteLine($"  âœ“ Found {pluginTypes.Count} IPlugin implementation(s)");
                      }
                      catch (ReflectionTypeLoadException ex)
                      {
                          var loaderExceptions = ex.LoaderExceptions
                              .Where(e => e != null)
                              .Select(e => e.Message)
                              .Distinct()
                              .ToList();
                          errors.Add($"{Path.GetFileName(dll)}: Type load errors - {string.Join("; ", loaderExceptions)}");
                          Console.WriteLine($"  âœ— Type load errors: {string.Join("; ", loaderExceptions.Take(3))}");
                      }
                      catch (Exception ex)
                      {
                          errors.Add($"{Path.GetFileName(dll)}: {ex.Message}");
                          Console.WriteLine($"  âœ— Failed: {ex.Message}");
                      }
                  }

                  Console.WriteLine();

                  // Check for conflicting types (would indicate ILRepack internalization failure)
                  Console.WriteLine("=== Checking for Type Conflicts ===");
                  var allTypes = new System.Collections.Generic.Dictionary<string, string>();
                  var conflicts = new System.Collections.Generic.List<string>();

                  foreach (var assembly in loadedAssemblies)
                  {
                      try
                      {
                          foreach (var type in assembly.GetExportedTypes())
                          {
                              var fullName = type.FullName;
                              if (allTypes.ContainsKey(fullName))
                              {
                                  conflicts.Add($"Type '{fullName}' found in both {allTypes[fullName]} and {assembly.GetName().Name}");
                              }
                              else
                              {
                                  allTypes[fullName] = assembly.GetName().Name;
                              }
                          }
                      }
                      catch { /* Ignore type enumeration errors */ }
                  }

                  if (conflicts.Any())
                  {
                      Console.WriteLine("âœ— Type conflicts detected (ILRepack internalization may have failed):");
                      foreach (var conflict in conflicts.Take(10))
                          Console.WriteLine($"  - {conflict}");
                      errors.AddRange(conflicts);
                  }
                  else
                  {
                      Console.WriteLine("âœ“ No type conflicts detected - ILRepack internalization working correctly");
                  }

                  Console.WriteLine();
                  Console.WriteLine("=== Summary ===");
                  Console.WriteLine($"Assemblies loaded: {loadedAssemblies.Count}/{pluginDlls.Length}");
                  Console.WriteLine($"Type conflicts: {conflicts.Count}");
                  Console.WriteLine($"Errors: {errors.Count}");

                  if (errors.Any())
                  {
                      Console.WriteLine();
                      Console.WriteLine("FAILED: Errors detected during assembly loading");
                      return 1;
                  }

                  Console.WriteLine();
                  Console.WriteLine("ðŸŽ‰ SUCCESS: All plugins can co-exist without conflicts!");
                  return 0;
              }
          }
          CSHARP_EOF

          # Compile and run the test
          echo "Compiling co-existence test..."
          dotnet new console -n AssemblyTest -o /tmp/assembly-test --force
          cp test-assemblies.cs /tmp/assembly-test/Program.cs

          # Update csproj to allow unsafe loading
          cat > /tmp/assembly-test/AssemblyTest.csproj << 'CSPROJ_EOF'
          <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
              <OutputType>Exe</OutputType>
              <TargetFramework>net6.0</TargetFramework>
              <ImplicitUsings>disable</ImplicitUsings>
              <Nullable>disable</Nullable>
            </PropertyGroup>
          </Project>
          CSPROJ_EOF

          cd /tmp/assembly-test
          dotnet build --configuration Release -v q

          echo ""
          echo "Running co-existence test..."
          echo ""
          dotnet run --configuration Release --no-build -- "${{ github.workspace }}/staged-plugins"

      - name: Verify Plugin Build Artifacts
        shell: bash
        run: |
          set -euo pipefail

          echo "=== Verifying Plugin Build Artifacts ==="
          echo ""

          # Check each plugin has required files
          PLUGINS_TO_CHECK="${{ inputs.test_plugins }}"
          IFS=',' read -ra PLUGIN_ARRAY <<< "$PLUGINS_TO_CHECK"

          FAILED=0
          for plugin in "${PLUGIN_ARRAY[@]}"; do
            plugin_name=$(echo "$plugin" | xargs)
            plugin_cap=$(echo "$plugin_name" | sed 's/.*/\u&/')
            plugin_dir="staged-plugins/${plugin_cap}"

            echo "Checking $plugin_cap..."

            if [ ! -d "$plugin_dir" ]; then
              echo "  âœ— Directory not found: $plugin_dir"
              FAILED=1
              continue
            fi

            # Check for main DLL
            DLL_COUNT=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" | wc -l)
            if [ "$DLL_COUNT" -eq 0 ]; then
              echo "  âœ— No plugin DLL found"
              FAILED=1
            else
              DLL_NAME=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" -exec basename {} \;)
              DLL_SIZE=$(find "$plugin_dir" -name "Lidarr.Plugin.*.dll" -exec stat -c%s {} \;)
              echo "  âœ“ Plugin DLL: $DLL_NAME ($DLL_SIZE bytes)"
            fi

            # Check for plugin.json
            if [ -f "$plugin_dir/plugin.json" ]; then
              VERSION=$(grep -oP '"version"\s*:\s*"\K[^"]+' "$plugin_dir/plugin.json" 2>/dev/null || echo "unknown")
              echo "  âœ“ plugin.json (version: $VERSION)"
            else
              echo "  âš  plugin.json not found (optional)"
            fi

            # Check for manifest.json
            if [ -f "$plugin_dir/manifest.json" ]; then
              echo "  âœ“ manifest.json present"
            else
              echo "  âš  manifest.json not found (optional)"
            fi
          done

          echo ""
          if [ $FAILED -eq 0 ]; then
            echo "ðŸŽ‰ All plugin artifacts verified successfully!"
          else
            echo "âœ— Some plugins missing required files"
            exit 1
          fi

      - name: Capture Debug Info on Failure
        if: failure()
        shell: bash
        run: |
          echo "=== Staged Plugin Contents ==="
          find staged-plugins -type f -exec ls -la {} \; 2>&1 || true

          echo ""
          echo "=== Plugin Directory Structure ==="
          find staged-plugins -type d 2>&1 || true

          echo ""
          echo "=== Build Output Directories ==="
          find plugins -path '*/bin/*' -name '*.dll' 2>&1 | head -50 || true
