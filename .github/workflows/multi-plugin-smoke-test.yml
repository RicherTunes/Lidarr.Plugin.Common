name: Multi-Plugin Smoke Test

on:
  workflow_dispatch:
    inputs:
      lidarr_tag:
        description: Lidarr Docker tag (plugins branch; must support net8 plugins)
        required: true
        default: pr-plugins-3.1.1.4884
      qobuzarr_ref:
        description: Qobuzarr branch/tag/SHA
        required: true
        default: main
      tidalarr_ref:
        description: Tidalarr branch/tag/SHA
        required: true
        default: main
      run_medium_gate:
        description: Configure + test indexers (requires credentials)
        type: boolean
        required: true
        default: false
      run_downloadclient_gate:
        description: Configure + test download clients (requires credentials)
        type: boolean
        required: true
        default: false
      run_search_gate:
        description: Run AlbumSearch + require releases (requires credentials)  
        type: boolean
        required: true
        default: false
      run_grab_gate:
        description: POST /api/v1/release to queue downloads (requires credentials)
        type: boolean
        required: true
        default: false
      require_downloaded_files:
        description: Require at least one downloaded file on disk (grab gate only; slow)
        type: boolean
        required: true
        default: false
      grab_timeout_seconds:
        description: Timeout for grab gate queue/files checks
        type: string
        required: true
        default: "300"
      require_all_indexers_in_search:
        description: Fail search unless releases include each configured indexer name
        type: boolean
        required: true
        default: false
      run_canary:
        description: Also run against moving tag "pr-plugins" (allowed to fail)
        type: boolean
        required: true
        default: false

permissions:
  contents: read

env:
  DOTNET_NOLOGO: "true"
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"

jobs:
  smoke-test:
    name: Smoke Test (${{ matrix.name }})
    if: ${{ matrix.name != 'canary' || inputs.run_canary }}
    continue-on-error: ${{ matrix.allow_failure }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: gate
            lidarr_tag: ${{ inputs.lidarr_tag }}
            allow_failure: false
          - name: canary
            lidarr_tag: pr-plugins
            allow_failure: true
    steps:
      - name: Preflight - Validate CROSS_REPO_PAT secret
        shell: bash
        env:
          CROSS_REPO_PAT: ${{ secrets.CROSS_REPO_PAT }}
        run: |
          set -euo pipefail
          echo "::add-mask::${CROSS_REPO_PAT:-}"

          if [[ -z "${CROSS_REPO_PAT:-}" ]]; then
            echo "::error::CROSS_REPO_PAT secret is missing or empty."
            echo ""
            echo "This workflow requires a Personal Access Token with 'repo' scope to checkout"
            echo "the private Qobuzarr and Tidalarr repositories."
            echo ""
            echo "To fix this:"
            echo "  1. Go to: https://github.com/settings/tokens"
            echo "  2. Create a PAT (classic) with 'repo' scope"
            echo "  3. Go to: https://github.com/RicherTunes/Lidarr.Plugin.Common/settings/secrets/actions"
            echo "  4. Add secret named 'CROSS_REPO_PAT' with the token value"
            echo ""
            echo "See docs/MULTI_PLUGIN_SMOKE_TEST.md for full setup instructions."
            exit 1
          fi
          echo "CROSS_REPO_PAT secret is configured"

      - name: Checkout Lidarr.Plugin.Common
        uses: actions/checkout@v6

      - name: Setup .NET SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            8.0.x

      - name: Checkout Qobuzarr
        uses: actions/checkout@v6
        with:
          repository: RicherTunes/Qobuzarr
          ref: ${{ inputs.qobuzarr_ref }}
          path: qobuzarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Checkout Tidalarr
        uses: actions/checkout@v6
        with:
          repository: RicherTunes/Tidalarr
          ref: ${{ inputs.tidalarr_ref }}
          path: tidalarr
          token: ${{ secrets.CROSS_REPO_PAT }}
          submodules: recursive

      - name: Extract Lidarr assemblies from Docker image
        shell: bash
        run: |
          set -euo pipefail
          echo "Extracting Lidarr assemblies from plugins branch Docker image..."

          IMAGE="ghcr.io/hotio/lidarr:${{ matrix.lidarr_tag }}"
          echo "Pulling $IMAGE (with retry)"

          n=0
          until [ "$n" -ge 3 ]; do
            docker pull "$IMAGE" && break
            n=$((n+1))
            echo "Pull failed ($n). Retrying in 10s..." && sleep 10
          done

          if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "ghcr.io/hotio/lidarr:${{ matrix.lidarr_tag }}"; then
            echo "::error::Failed to pull Docker image $IMAGE after 3 attempts"
            exit 1
          fi

          echo "Creating temporary container..."
          cid=$(docker create "$IMAGE")

          echo "Extracting assemblies from container..."
          mkdir -p _lidarr_extracted
          docker cp "$cid:/app" _lidarr_extracted/ 2>/dev/null || docker cp "$cid:/opt/lidarr" _lidarr_extracted/ 2>/dev/null || {
            echo "::error::Could not extract from /app or /opt/lidarr"
            docker rm "$cid" >/dev/null
            exit 1
          }
          docker rm "$cid" >/dev/null

          echo "Copying assemblies to plugin ext directories..."

          # Create target directories for both plugins
          mkdir -p qobuzarr/ext/Lidarr/_output/net8.0
          mkdir -p tidalarr/ext/Lidarr/_output/net8.0

          # Copy all DLLs to both plugin directories
          find _lidarr_extracted -type f -name "*.dll" -exec cp {} qobuzarr/ext/Lidarr/_output/net8.0/ \;
          find _lidarr_extracted -type f -name "*.dll" -exec cp {} tidalarr/ext/Lidarr/_output/net8.0/ \;

          # Verify critical assemblies exist
          for plugin_dir in qobuzarr tidalarr; do
            if [ ! -f "$plugin_dir/ext/Lidarr/_output/net8.0/Lidarr.dll" ]; then
              echo "::error::Missing Lidarr.dll in $plugin_dir after extraction"
              ls -la "$plugin_dir/ext/Lidarr/_output/net8.0/" || true
              exit 1
            fi
          done

          echo "Assembly extraction complete:"
          ls -la qobuzarr/ext/Lidarr/_output/net8.0/Lidarr*.dll || true

          # Cleanup
          rm -rf _lidarr_extracted

      - name: Sync tools from main checkout to submodules
        shell: bash
        run: |
          set -euo pipefail
          echo "Syncing tools and build assets from main checkout to plugin submodules..."

          # Both plugins have submodules at ext/Lidarr.Plugin.Common
          # The submodules may point to older commits, so we sync from this checkout
          for plugin_dir in qobuzarr tidalarr; do
            submod_common="$plugin_dir/ext/Lidarr.Plugin.Common"
            if [ -d "$submod_common" ]; then
              echo "Syncing to $submod_common..."

              # Sync tools directory (includes ManifestCheck.ps1, PluginPack.psm1)
              if [ -d "tools" ]; then
                rm -rf "$submod_common/tools"
                cp -r tools "$submod_common/tools"
                echo "  - tools/ synced"
              fi

              # Sync build directory (includes PluginPackaging.targets)
              if [ -d "build" ]; then
                rm -rf "$submod_common/build"
                cp -r build "$submod_common/build"
                echo "  - build/ synced"
              fi
            else
              echo "Warning: $submod_common not found, skipping sync"
            fi
          done

          echo "Tool sync complete"

      - name: Build Qobuzarr package
        shell: pwsh
        working-directory: qobuzarr
        run: |
          $buildSuccess = $false
          try {
            ./build.ps1 -Configuration Release -Restore -Package -VerboseOutput
            if ($LASTEXITCODE -eq 0) { $buildSuccess = $true }
          } catch {
            Write-Host "build.ps1 threw exception: $_" -ForegroundColor Red
          }
          if (-not $buildSuccess) {
            Write-Host ""
            Write-Host "::group::Detailed build error output"
            dotnet restore --verbosity quiet 2>&1 | Out-Null
            dotnet build Qobuzarr.csproj --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            Write-Host "::endgroup::"
            exit 1
          }

      - name: Build Tidalarr package
        shell: pwsh
        working-directory: tidalarr
        run: |
          $buildSuccess = $false
          try {
            ./build.ps1 -Configuration Release -Restore -Package -VerboseOutput
            if ($LASTEXITCODE -eq 0) { $buildSuccess = $true }
          } catch {
            Write-Host "build.ps1 threw exception: $_" -ForegroundColor Red
          }
          if (-not $buildSuccess) {
            Write-Host ""
            Write-Host "::group::Detailed build error output"
            dotnet restore --verbosity quiet 2>&1 | Out-Null
            $csproj = Get-ChildItem -Filter "*.csproj" | Where-Object { $_.Name -notmatch "Tests" } | Select-Object -First 1
            if ($csproj) {
              dotnet build $csproj.Name --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            } else {
              dotnet build --configuration Release --no-restore --verbosity normal -p:RunAnalyzersDuringBuild=false -p:EnableNETAnalyzers=false -p:TreatWarningsAsErrors=false 2>&1
            }
            Write-Host "::endgroup::"
            exit 1
          }

      - name: Locate plugin zips
        shell: pwsh
        run: |
          function Find-PluginZip {
            param(
              [Parameter(Mandatory=$true)][string]$RepoDir,
              [Parameter(Mandatory=$true)][string]$NamePattern
            )

            $root = Resolve-Path $RepoDir

            # Strategy 1: Prefer plugin.json-adjacent zips (canonical build output)
            $manifestFiles = Get-ChildItem -Path $root -Recurse -File -Filter 'plugin.json' -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' }

            foreach ($manifest in $manifestFiles) {
              $dir = $manifest.DirectoryName
              $adjacentZips = Get-ChildItem -Path $dir -File -Filter '*.zip' -ErrorAction SilentlyContinue |
                Where-Object { $_.Name -match $NamePattern } |
                Sort-Object LastWriteTimeUtc -Descending
              $zip = $adjacentZips | Select-Object -First 1
              if ($zip) {
                Write-Host "Found plugin.json-adjacent zip: $($zip.FullName)"
                return $zip.FullName
              }
            }

            # Strategy 2: Fallback to latest zip anywhere (legacy/fallback)
            Write-Host "No plugin.json-adjacent zip found, falling back to latest zip search..."
            $candidates = Get-ChildItem -Path $root -Recurse -File -Filter '*.zip' -ErrorAction Stop |
              Where-Object {
                $_.FullName -notmatch '[\\/](\.git|ext|obj)[\\/]' -and
                $_.Name -match $NamePattern
              } |
              Sort-Object LastWriteTimeUtc -Descending

            $zip = $candidates | Select-Object -First 1
            if (-not $zip) {
              throw "Could not find a zip for '$RepoDir' matching pattern '$NamePattern'."
            }
            Write-Host "Found fallback zip: $($zip.FullName)"
            return $zip.FullName
          }

          $qobuzZip = Find-PluginZip -RepoDir 'qobuzarr' -NamePattern 'Qobuzarr'
          $tidalZip = Find-PluginZip -RepoDir 'tidalarr' -NamePattern 'Tidalarr'

          "QOBUZ_ZIP=$qobuzZip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "TIDAL_ZIP=$tidalZip" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          Write-Host "Qobuzarr zip: $qobuzZip"
          Write-Host "Tidalarr zip: $tidalZip"

      - name: Validate credentials (if gates enabled)
        if: ${{ inputs.run_medium_gate || inputs.run_downloadclient_gate || inputs.run_search_gate || inputs.run_grab_gate }}
        shell: bash
        env:
          QOBUZARR_EMAIL: ${{ secrets.QOBUZARR_EMAIL }}
          QOBUZARR_PASSWORD: ${{ secrets.QOBUZARR_PASSWORD }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_APP_ID: ${{ secrets.QOBUZARR_APP_ID }}
          QOBUZARR_APP_SECRET: ${{ secrets.QOBUZARR_APP_SECRET }}
          QOBUZ_EMAIL: ${{ secrets.QOBUZ_EMAIL }}
          QOBUZ_PASSWORD: ${{ secrets.QOBUZ_PASSWORD }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_APP_ID: ${{ secrets.QOBUZ_APP_ID }}
          QOBUZ_APP_SECRET: ${{ secrets.QOBUZ_APP_SECRET }}
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_MARKET: ${{ secrets.TIDALARR_MARKET }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          TIDAL_MARKET: ${{ secrets.TIDAL_MARKET }}
        run: |
          set -euo pipefail

          has_qobuz_email=false
          if [[ -n "${QOBUZARR_EMAIL:-}" && -n "${QOBUZARR_PASSWORD:-}" ]]; then has_qobuz_email=true; fi
          if [[ -n "${QOBUZ_EMAIL:-}" && -n "${QOBUZ_PASSWORD:-}" ]]; then has_qobuz_email=true; fi

          has_qobuz_token=false
          if [[ -n "${QOBUZARR_USER_ID:-}" && -n "${QOBUZARR_AUTH_TOKEN:-}" ]]; then has_qobuz_token=true; fi
          if [[ -n "${QOBUZ_USER_ID:-}" && -n "${QOBUZ_AUTH_TOKEN:-}" ]]; then has_qobuz_token=true; fi

          has_tidal=false
          if [[ -n "${TIDALARR_REDIRECT_URL:-}" || -n "${TIDAL_REDIRECT_URL:-}" ]]; then has_tidal=true; fi

          if [[ "$has_qobuz_email" != "true" && "$has_qobuz_token" != "true" && "$has_tidal" != "true" ]]; then
            echo "Credentials are required for the selected gates, but no supported secret set was found."
            echo "Provide at least one provider credential set (Qobuz email/password or token; or Tidal redirect URL)."
            exit 1
          fi

      - name: Run multi-plugin harness
        shell: pwsh
        env:
          QOBUZARR_EMAIL: ${{ secrets.QOBUZARR_EMAIL }}
          QOBUZARR_PASSWORD: ${{ secrets.QOBUZARR_PASSWORD }}
          QOBUZARR_USER_ID: ${{ secrets.QOBUZARR_USER_ID }}
          QOBUZARR_AUTH_TOKEN: ${{ secrets.QOBUZARR_AUTH_TOKEN }}
          QOBUZARR_APP_ID: ${{ secrets.QOBUZARR_APP_ID }}
          QOBUZARR_APP_SECRET: ${{ secrets.QOBUZARR_APP_SECRET }}
          QOBUZARR_COUNTRY_CODE: ${{ secrets.QOBUZARR_COUNTRY_CODE }}
          QOBUZ_EMAIL: ${{ secrets.QOBUZ_EMAIL }}
          QOBUZ_PASSWORD: ${{ secrets.QOBUZ_PASSWORD }}
          QOBUZ_USER_ID: ${{ secrets.QOBUZ_USER_ID }}
          QOBUZ_AUTH_TOKEN: ${{ secrets.QOBUZ_AUTH_TOKEN }}
          QOBUZ_APP_ID: ${{ secrets.QOBUZ_APP_ID }}
          QOBUZ_APP_SECRET: ${{ secrets.QOBUZ_APP_SECRET }}
          QOBUZ_COUNTRY_CODE: ${{ secrets.QOBUZ_COUNTRY_CODE }}
          TIDALARR_REDIRECT_URL: ${{ secrets.TIDALARR_REDIRECT_URL }}
          TIDALARR_MARKET: ${{ secrets.TIDALARR_MARKET }}
          TIDAL_REDIRECT_URL: ${{ secrets.TIDAL_REDIRECT_URL }}
          TIDAL_MARKET: ${{ secrets.TIDAL_MARKET }}
        run: |
          $containerName = "lidarr-multi-${{ matrix.name }}-${{ github.run_id }}-${{ github.run_attempt }}"
          "SMOKE_CONTAINER_NAME=$containerName" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          $params = @{
            LidarrTag = "${{ matrix.lidarr_tag }}"
            ContainerName = $containerName
            PluginZip = @("qobuzarr=$env:QOBUZ_ZIP", "tidalarr=$env:TIDAL_ZIP")
            KeepRunning = $true
          }

          if ("${{ inputs.run_medium_gate }}" -eq "true") { $params.RunMediumGate = $true }
          if ("${{ inputs.run_downloadclient_gate }}" -eq "true") { $params.RunDownloadClientGate = $true }
          if ("${{ inputs.run_search_gate }}" -eq "true") { $params.RunSearchGate = $true }
          if ("${{ inputs.run_grab_gate }}" -eq "true") { $params.RunGrabGate = $true }
          if ("${{ inputs.require_downloaded_files }}" -eq "true") { $params.RequireDownloadedFiles = $true }
          if (-not [string]::IsNullOrWhiteSpace("${{ inputs.grab_timeout_seconds }}")) { $params.GrabTimeoutSeconds = [int]"${{ inputs.grab_timeout_seconds }}" }
          if ("${{ inputs.require_all_indexers_in_search }}" -eq "true") { $params.RequireAllConfiguredIndexersInSearch = $true }

          & ./scripts/multi-plugin-docker-smoke-test.ps1 @params

      - name: Collect container diagnostics
        if: always()
        shell: bash
        run: |
          set +e
          mkdir -p .docker-multi-smoke-test/diagnostics

          echo "::group::All containers (docker ps -a)"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}" | tee .docker-multi-smoke-test/diagnostics/containers.txt || true
          echo "::endgroup::"

          if docker ps -a --format '{{.Names}}' | grep -q "^${SMOKE_CONTAINER_NAME:-}$"; then
            echo "::group::Container logs (${SMOKE_CONTAINER_NAME})"
            docker logs "${SMOKE_CONTAINER_NAME}" --tail 5000 2>&1 | tee .docker-multi-smoke-test/diagnostics/container.log || true
            echo "::endgroup::"

            echo "::group::Container inspect"
            docker inspect "${SMOKE_CONTAINER_NAME}" > .docker-multi-smoke-test/diagnostics/inspect.json 2> .docker-multi-smoke-test/diagnostics/inspect.error.txt || true
            echo "::endgroup::"

            docker rm -f "${SMOKE_CONTAINER_NAME}" || true
          else
            echo "Container ${SMOKE_CONTAINER_NAME:-<unknown>} not found"
          fi

      - name: Upload smoke artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: multi-plugin-smoke-${{ matrix.name }}-artifacts
          path: |
            ${{ env.QOBUZ_ZIP }}
            ${{ env.TIDAL_ZIP }}
            .docker-multi-smoke-test/
          if-no-files-found: warn
