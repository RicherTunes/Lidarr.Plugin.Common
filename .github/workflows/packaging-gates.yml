name: Packaging Gates (Reusable)

on:
  workflow_call:
    inputs:
      common-path:
        description: "Path to lidarr.plugin.common submodule in the caller repo"
        required: true
        type: string
      plugin-csproj:
        description: "Path to the plugin .csproj to build/package"
        required: true
        type: string
      manifest-path:
        description: "Path to plugin.json to validate"
        required: true
        type: string
      framework:
        description: "Target framework to package"
        required: false
        type: string
        default: "net8.0"
      configuration:
        description: "Build configuration"
        required: false
        type: string
        default: "Release"
      publish-path:
        description: "Publish output path (optional). If omitted, derived from plugin-csproj/framework/configuration."
        required: false
        type: string
        default: ""
      packages-path:
        description: "Packages output folder (optional). If omitted, derived from plugin-csproj."
        required: false
        type: string
        default: ""
      man004-cutoff:
        description: "Date (YYYY-MM-DD) after which MAN004 legacy manifest keys become a hard error"
        required: false
        type: string
        default: "2026-03-01"
      parity-lint:
        description: "Run parity lint (recommended)"
        required: false
        type: boolean
        default: true
      plugin-load-gate:
        description: "Load plugin package via Abstractions PluginLoader and create components (Abstractions-based plugins only)"
        required: false
        type: boolean
        default: false
      additional-keep-assemblies:
        description: "Semicolon-separated list of additional runtime DLL name patterns to keep (advanced; e.g. 'My.Plugin.Core.dll;Vendor.*.dll')"
        required: false
        type: string
        default: ""
      lidarr-docker-version:
        description: "Lidarr docker tag to extract host assemblies for plugin-load gate and pre-build setup (e.g. 'pr-plugins-3.1.1.4884')"
        required: false
        type: string
        default: "pr-plugins-3.1.2.4913"
      host-assemblies-path:
        description: "Path to populate with Lidarr host assemblies before build (e.g. 'ext/Lidarr/_output/net8.0'). When set, extracts DLLs from lidarr-docker-version image. Required for plugins that reference Lidarr host types at compile time."
        required: false
        type: string
        default: ""
    secrets:
      submodules-token:
        description: "Optional token to checkout private submodules"
        required: false

permissions:
  contents: read

jobs:
  packaging-gates:
    name: Packaging Gates
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Init submodules
        shell: bash
        env:
          SUBMODULES_TOKEN: ${{ secrets.submodules-token }}
          COMMON_PATH: ${{ inputs.common-path }}
        run: |
          # If a PAT is provided for private submodules, configure URL rewrite
          # so git uses the PAT instead of the default github.token credential.
          if [ -n "$SUBMODULES_TOKEN" ]; then
            git config --global url."https://x-access-token:${SUBMODULES_TOKEN}@github.com/".insteadOf "https://github.com/"
          fi

          # Init only the Common submodule (required for packaging tooling).
          # Other submodules (e.g. private SDKs) are not needed for packaging gates
          # and may fail auth if the PAT doesn't cover them.
          git submodule update --init -- "$COMMON_PATH"

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "8.0.x"

      - name: Setup host assemblies (pre-build)
        if: ${{ inputs.host-assemblies-path != '' }}
        shell: bash
        run: |
          set -euo pipefail
          HOST_PATH="${{ inputs.host-assemblies-path }}"
          LIDARR_TAG="${{ inputs.lidarr-docker-version }}"
          IMAGE="ghcr.io/hotio/lidarr:${LIDARR_TAG}"

          echo "Extracting Lidarr host assemblies from ${IMAGE} to ${HOST_PATH}..."
          mkdir -p "${HOST_PATH}"

          # Pull with retry
          n=0
          until [ "$n" -ge 3 ]; do
            docker pull "${IMAGE}" && break
            n=$((n+1))
            echo "Pull attempt ${n} failed. Retrying in 10s..." && sleep 10
          done

          cid=$(docker create "${IMAGE}")
          trap 'docker rm "${cid}" >/dev/null 2>&1 || true' EXIT

          # Extract to temp dir, then copy DLLs to target
          EXTRACT_DIR=$(mktemp -d)
          docker cp "${cid}:/app/bin/." "${EXTRACT_DIR}" 2>/dev/null \
            || docker cp "${cid}:/app/." "${EXTRACT_DIR}" 2>/dev/null \
            || docker cp "${cid}:/opt/lidarr/." "${EXTRACT_DIR}" 2>/dev/null \
            || { echo "::error::Failed to extract from container"; exit 1; }

          find "${EXTRACT_DIR}" -type f \( -name "*.dll" -o -name "*.json" \) -exec cp {} "${HOST_PATH}/" \;
          rm -rf "${EXTRACT_DIR}"

          # Verify critical assembly exists
          if [ ! -f "${HOST_PATH}/Lidarr.dll" ]; then
            echo "::error::Lidarr.dll not found after extraction to ${HOST_PATH}"
            ls -la "${HOST_PATH}/" || true
            exit 1
          fi

          DLL_COUNT=$(find "${HOST_PATH}" -name "*.dll" | wc -l)
          echo "Extracted ${DLL_COUNT} assemblies to ${HOST_PATH}"

      - name: Runtime guardrail (.NET 8)
        if: ${{ inputs.host-assemblies-path != '' }}
        shell: bash
        run: |
          GUARDRAIL="${{ inputs.common-path }}/scripts/ci/assert-net8-runtime.sh"
          if [ -f "$GUARDRAIL" ]; then
            bash "$GUARDRAIL" "${{ inputs.host-assemblies-path }}"
          else
            echo "::warning::assert-net8-runtime.sh not found in Common â€” skipping guardrail"
          fi

      - name: Package (Common tooling)
        id: package
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $commonPath = '${{ inputs.common-path }}'
          $csproj = '${{ inputs.plugin-csproj }}'
          $manifest = '${{ inputs.manifest-path }}'
          $framework = '${{ inputs.framework }}'
          $configuration = '${{ inputs.configuration }}'
          $additionalKeepRaw = '${{ inputs.additional-keep-assemblies }}'
          $additionalKeep = @()
          if (-not [string]::IsNullOrWhiteSpace($additionalKeepRaw)) {
            $additionalKeep = ($additionalKeepRaw -split '[;\\r\\n]+' | Where-Object { -not [string]::IsNullOrWhiteSpace($_) })
          }

          if (-not (Test-Path -LiteralPath $commonPath)) { throw "Common path not found: $commonPath" }
          $pluginPack = Join-Path $commonPath 'tools/PluginPack.psm1'
          if (-not (Test-Path -LiteralPath $pluginPack)) { throw "PluginPack.psm1 not found: $pluginPack" }

          Import-Module (Resolve-Path -LiteralPath $pluginPack) -Force

          $zipPath = (New-PluginPackage `
            -Csproj $csproj `
            -Manifest $manifest `
            -Framework $framework `
            -Configuration $configuration `
            -RequireCanonicalAbstractions `
            -ResolveEntryPoints `
            -AdditionalKeepAssemblies $additionalKeep | Select-Object -Last 1)

          if (-not $zipPath) { throw "New-PluginPackage returned an empty path." }
          if (-not (Test-Path -LiteralPath $zipPath)) { throw "Package not found at: $zipPath" }

          "zipPath=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Manifest gates (MAN004 escalation)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $commonPath = '${{ inputs.common-path }}'
          $csproj = '${{ inputs.plugin-csproj }}'
          $manifest = '${{ inputs.manifest-path }}'
          $framework = '${{ inputs.framework }}'
          $configuration = '${{ inputs.configuration }}'

          $publishPath = '${{ inputs.publish-path }}'
          if ([string]::IsNullOrWhiteSpace($publishPath)) {
            $projectDir = Split-Path -Parent (Resolve-Path -LiteralPath $csproj)
            $publishPath = Join-Path $projectDir "artifacts/publish/$framework/$configuration"
          }

          $manifestScript = Join-Path $commonPath 'tools/ManifestCheck.ps1'
          if (-not (Test-Path -LiteralPath $manifestScript)) { throw "ManifestCheck.ps1 not found: $manifestScript" }

          $jsonText = & $manifestScript `
            -ProjectPath $csproj `
            -ManifestPath $manifest `
            -PublishPath $publishPath `
            -ResolveEntryPoints `
            -JsonOutput

          $exitCode = $LASTEXITCODE
          $diags = @()
          $rawJson = if ($jsonText -is [array]) { $jsonText -join "`n" } else { [string]$jsonText }
          if (-not [string]::IsNullOrWhiteSpace($rawJson)) { $diags = @($rawJson | ConvertFrom-Json) }

          if ($exitCode -ne 0) {
            $errors = @($diags | Where-Object { $_.severity -eq 'Error' } | ForEach-Object { $_.message })
            if ($errors.Count -gt 0) {
              $errors | ForEach-Object { Write-Host "::error::$_" }
            }
            throw "ManifestCheck failed (exit code $exitCode)."
          }

          $man004 = @(
            $diags | Where-Object {
              ($_.id -eq 'MAN004') -or ($_.message -match '^MAN004:')
            }
          )

          if ($man004.Count -gt 0) {
            $cutoffRaw = '${{ inputs.man004-cutoff }}'
            try {
              $cutoff = [DateTime]::ParseExact($cutoffRaw, 'yyyy-MM-dd', [Globalization.CultureInfo]::InvariantCulture)
            } catch {
              throw "Invalid man004-cutoff '$cutoffRaw'. Expected YYYY-MM-DD."
            }

            $now = Get-Date
            $messages = $man004 | ForEach-Object { $_.message }

            if ($now -ge $cutoff) {
              $messages | ForEach-Object { Write-Host "::error::$_" }
              throw "MAN004 legacy manifest keys are no longer allowed after $cutoffRaw."
            } else {
              $messages | ForEach-Object { Write-Host "::warning::$_" }
              Write-Host "MAN004 is currently a warning until $cutoffRaw." -ForegroundColor Yellow
            }
          }

      - name: Canonical Abstractions gate
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $commonPath = '${{ inputs.common-path }}'
          $zipPath = '${{ steps.package.outputs.zipPath }}'
          if (-not (Test-Path -LiteralPath $zipPath)) { throw "Package not found: $zipPath" }

          $configPath = Join-Path $commonPath 'tools/canonical-abstractions.json'
          if (-not (Test-Path -LiteralPath $configPath)) { throw "Canonical config not found: $configPath" }
          $config = Get-Content -LiteralPath $configPath -Raw | ConvertFrom-Json
          $expected = [string]$config.abstractionsSha256
          if ([string]::IsNullOrWhiteSpace($expected)) { throw "canonical-abstractions.json missing 'abstractionsSha256'." }

          $verifyScript = Join-Path $commonPath 'scripts/Verify-CanonicalAbstractions.ps1'
          if (-not (Test-Path -LiteralPath $verifyScript)) { throw "Verify-CanonicalAbstractions.ps1 not found: $verifyScript" }

          & $verifyScript -PackagePaths @($zipPath) -ExpectedSha256 $expected | Out-Null

      - name: Contents manifest gate
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $manifestFile = 'packaging/expected-contents.txt'
          if (-not (Test-Path -LiteralPath $manifestFile)) {
            Write-Host "::notice::No packaging/expected-contents.txt found -- skipping contents gate (opt-in)."
            return
          }

          $zipPath = '${{ steps.package.outputs.zipPath }}'
          if (-not (Test-Path -LiteralPath $zipPath)) { throw "Package not found: $zipPath" }

          # Parse manifest (file names only, case-insensitive matching)
          $required = @()
          $forbidden = @()
          $section = $null
          Get-Content -LiteralPath $manifestFile | ForEach-Object {
            $line = $_.Trim()
            if ($line -eq '' -or $line.StartsWith('#')) { return }
            if ($line -eq '[REQUIRED]') { $section = 'required'; return }
            if ($line -eq '[FORBIDDEN]') { $section = 'forbidden'; return }
            if ($section -eq 'required') { $required += $line.ToLowerInvariant() }
            if ($section -eq 'forbidden') { $forbidden += $line.ToLowerInvariant() }
          }

          # List ZIP entry file names (leaf name only, lowercased for comparison)
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          try {
            $entries = @($zip.Entries | ForEach-Object { $_.Name })
          } finally {
            $zip.Dispose()
          }
          $entriesLower = @($entries | ForEach-Object { $_.ToLowerInvariant() })

          Write-Host "ZIP contains $($entries.Count) file(s): $($entries -join ', ')"

          $missing = @()
          $illegal = @()

          foreach ($req in $required) {
            if ($req -notin $entriesLower) { $missing += $req }
          }

          foreach ($entry in $entriesLower) {
            if ($entry -in $forbidden) { $illegal += $entry }
          }

          # Single summary output
          if (($missing.Count + $illegal.Count) -gt 0) {
            if ($missing.Count -gt 0) {
              Write-Host "::error::Missing REQUIRED: $($missing -join ', ')"
            }
            if ($illegal.Count -gt 0) {
              Write-Host "::error::Found FORBIDDEN: $($illegal -join ', ')"
            }
            throw "Contents manifest gate failed: $($missing.Count) missing, $($illegal.Count) forbidden."
          }

          Write-Host "Contents manifest gate passed -- $($required.Count) required present, 0 forbidden found."

      - name: Plugin load gate
        if: ${{ inputs.plugin-load-gate }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $commonPath = '${{ inputs.common-path }}'
          $manifestPath = '${{ inputs.manifest-path }}'
          $zipPath = '${{ steps.package.outputs.zipPath }}'
          $lidarrTag = '${{ inputs.lidarr-docker-version }}'

          if (-not (Test-Path -LiteralPath $zipPath)) { throw "Package not found: $zipPath" }
          if (-not (Test-Path -LiteralPath $manifestPath)) { throw "Manifest not found: $manifestPath" }

          $manifest = Get-Content -LiteralPath $manifestPath -Raw | ConvertFrom-Json
          $pluginId = [string]$manifest.id
          if ([string]::IsNullOrWhiteSpace($pluginId)) { throw "Manifest missing 'id'." }

          $pluginsRoot = Join-Path $env:RUNNER_TEMP 'plugin-load-gate/plugins'
          New-Item -ItemType Directory -Force -Path $pluginsRoot | Out-Null

          $pluginDir = Join-Path $pluginsRoot $pluginId
          if (Test-Path -LiteralPath $pluginDir) { Remove-Item -Recurse -Force -LiteralPath $pluginDir }
          New-Item -ItemType Directory -Force -Path $pluginDir | Out-Null

          Expand-Archive -LiteralPath $zipPath -DestinationPath $pluginDir -Force
          $packagedManifest = Join-Path $pluginDir 'plugin.json'
          if (-not (Test-Path -LiteralPath $packagedManifest)) { throw "plugin.json missing from extracted package (expected: $packagedManifest)" }

          $sampleProj = Join-Path $commonPath 'examples/IsolationHostSample/IsolationHostSample.csproj'
          if (-not (Test-Path -LiteralPath $sampleProj)) { throw "IsolationHostSample.csproj not found: $sampleProj" }

          $hostRoot = Join-Path $env:RUNNER_TEMP 'plugin-load-gate/host'
          New-Item -ItemType Directory -Force -Path $hostRoot | Out-Null

          if (-not [string]::IsNullOrWhiteSpace($lidarrTag)) {
            $image = "ghcr.io/hotio/lidarr:$lidarrTag"
            Write-Host "Extracting host assemblies from $image..." -ForegroundColor Cyan
            $cid = (& docker create $image 2>$null).Trim()
            if (-not $cid) { throw "Failed to create Lidarr container for $image." }
            try {
              & docker cp "$cid`:/app/bin/." $hostRoot | Out-Null
            } finally {
              & docker rm $cid | Out-Null
            }
          }

          $lidarrCore = Get-ChildItem -LiteralPath $hostRoot -Recurse -Filter 'Lidarr.Core.dll' -File -ErrorAction SilentlyContinue | Select-Object -First 1
          $hostAssembliesDir = if ($lidarrCore) { $lidarrCore.Directory.FullName } else { $hostRoot }

          dotnet run --project $sampleProj -c Release -- `
            $pluginsRoot `
            --ci `
            --create-components `
            --host-version 99.0.0.0 `
            --host-assemblies-dir $hostAssembliesDir

      - name: Parity lint
        if: ${{ inputs.parity-lint }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest

          $commonPath = '${{ inputs.common-path }}'
          $lint = Join-Path $commonPath 'scripts/parity-lint.ps1'
          if (-not (Test-Path -LiteralPath $lint)) { throw "parity-lint.ps1 not found: $lint" }

          & $lint -RepoPath . -Mode ci

      - name: Upload package artifact
        if: always()
        uses: actions/upload-artifact@v7
        with:
          name: plugin-package
          path: ${{ steps.package.outputs.zipPath }}
